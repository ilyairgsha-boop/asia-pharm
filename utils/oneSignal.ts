/**
 * OneSignal Push Notifications Utility
 * Handles all push notification operations for Asia Pharm
 * 
 * DEBUG COMMANDS (console):
 * - Check if configured: oneSignalService.isConfigured()
 * - Get settings: localStorage.getItem('oneSignalSettings')
 * - Force reload: oneSignalService.reloadSettings()
 * - Check subscription: await oneSignalService.isSubscribed()
 * - Get user ID: await oneSignalService.getUserId()
 */

import { getServerUrl } from './supabase/client';

export interface PushNotificationData {
  title: string;
  message: string;
  url?: string;
  icon?: string;
  image?: string;
  data?: Record<string, any>;
}

export interface SegmentOptions {
  userIds?: string[];
  segments?: string[];
  tags?: Record<string, string>;
  language?: string;
  store?: 'china' | 'thailand' | 'vietnam';
}

export class OneSignalService {
  private appId: string;
  private apiKey: string;
  private apiUrl = 'https://onesignal.com/api/v1';
  private isInitialized = false;

  constructor() {
    // Get credentials from environment or localStorage
    this.reloadSettings();
  }

  /**
   * Reload settings from localStorage
   */
  reloadSettings() {
    const settings = this.getSettings();
    this.appId = settings.appId || '';
    this.apiKey = settings.apiKey || '';
    // Don't reset isInitialized flag when reloading settings
  }

  /**
   * Get OneSignal settings from localStorage
   */
  private getSettings() {
    try {
      const settings = localStorage.getItem('oneSignalSettings');
      const parsed = settings ? JSON.parse(settings) : {};
      
      console.log('üìã OneSignal settings loaded:', {
        enabled: parsed.enabled,
        hasAppId: !!parsed.appId,
        hasApiKey: !!parsed.apiKey,
        appIdLength: parsed.appId?.length,
      });
      
      return parsed;
    } catch (error) {
      console.error('Error loading OneSignal settings:', error);
      return {};
    }
  }

  /**
   * Check if OneSignal is configured (credentials are set)
   */
  isConfigured(): boolean {
    const settings = this.getSettings();
    return !!(settings.appId && settings.apiKey);
  }

  /**
   * Check if OneSignal is enabled and configured
   */
  isEnabled(): boolean {
    const settings = this.getSettings();
    return !!(settings.enabled && settings.appId && settings.apiKey);
  }

  /**
   * Initialize OneSignal SDK in browser
   */
  async initializeSDK(): Promise<void> {
    // Reload settings to get latest values
    this.reloadSettings();
    
    if (!this.isEnabled()) {
      console.log('‚ÑπÔ∏è OneSignal not enabled or not configured, skipping initialization');
      return;
    }

    // Check if OneSignal is already initialized globally
    if (window.OneSignal && window.OneSignal.initialized) {
      console.log('‚úÖ OneSignal already initialized globally, skipping');
      this.isInitialized = true;
      return;
    }

    // If already initialized in our service, skip
    if (this.isInitialized) {
      console.log('‚úÖ OneSignal already initialized in service, skipping');
      return;
    }

    // Check if script is already loaded
    const existingScript = document.querySelector('script[src*="OneSignalSDK"]');
    
    if (!existingScript) {
      // Load OneSignal SDK
      console.log('üì• Loading OneSignal SDK script...');
      const script = document.createElement('script');
      script.src = 'https://cdn.onesignal.com/sdks/OneSignalSDK.js';
      script.async = true;
      document.head.appendChild(script);

      await new Promise<void>((resolve, reject) => {
        script.onload = () => {
          console.log('‚úÖ OneSignal SDK script loaded');
          this.initializeOneSignal().then(resolve).catch(reject);
        };
        script.onerror = () => {
          reject(new Error('Failed to load OneSignal SDK'));
        };
      });
    } else {
      // Script already loaded
      console.log('üìù OneSignal SDK script already loaded');
      if (!window.OneSignal || !window.OneSignal.initialized) {
        // Not yet initialized, initialize now
        await this.initializeOneSignal();
      } else {
        // Already initialized
        console.log('‚úÖ OneSignal SDK already initialized');
        this.isInitialized = true;
      }
    }
  }

  /**
   * Initialize OneSignal with current settings
   */
  private async initializeOneSignal(): Promise<void> {
    // Double-check if already initialized
    if (window.OneSignal && window.OneSignal.initialized) {
      console.log('‚ö†Ô∏è OneSignal already initialized, skipping init call');
      this.isInitialized = true;
      return Promise.resolve();
    }
    
    console.log('üîß Initializing OneSignal with App ID:', this.appId);
    
    return new Promise<void>((resolve) => {
      window.OneSignal = window.OneSignal || [];
      window.OneSignal.push(() => {
        window.OneSignal.init({
          appId: this.appId,
          allowLocalhostAsSecureOrigin: true,
          notifyButton: {
            enable: false,
          },
        });
        this.isInitialized = true;
        console.log('‚úÖ OneSignal initialized with App ID:', this.appId);
        resolve();
      });
    });
  }

  /**
   * Subscribe user to push notifications
   */
  async subscribe(): Promise<string | null> {
    if (!window.OneSignal) {
      await this.initializeSDK();
    }

    try {
      await window.OneSignal.push(['registerForPushNotifications']);
      const userId = await window.OneSignal.push(['getUserId']);
      return userId;
    } catch (error) {
      console.error('Error subscribing to push notifications:', error);
      return null;
    }
  }

  /**
   * Get current user's OneSignal player ID
   */
  async getUserId(): Promise<string | null> {
    if (!window.OneSignal) {
      return null;
    }

    try {
      const userId = await window.OneSignal.push(['getUserId']);
      return userId;
    } catch (error) {
      console.error('Error getting user ID:', error);
      return null;
    }
  }

  /**
   * Check if user is subscribed
   */
  async isSubscribed(): Promise<boolean> {
    if (!window.OneSignal) {
      return false;
    }

    try {
      const isPushEnabled = await window.OneSignal.push(['isPushNotificationsEnabled']);
      return isPushEnabled;
    } catch (error) {
      console.error('Error checking subscription status:', error);
      return false;
    }
  }

  /**
   * Send push notification via OneSignal API through Edge Function
   * Note: Settings must be configured in KV store for this to work
   */
  async sendNotification(
    data: PushNotificationData,
    options: SegmentOptions = {}
  ): Promise<{ id: string; recipients: number } | null> {
    if (!this.isEnabled()) {
      console.error('OneSignal not enabled or not configured');
      return null;
    }

    try {
      console.log('üì§ Sending notification via Edge Function:', {
        title: data.title,
        message: data.message.substring(0, 50) + '...',
        targeting: options,
      });
      
      // Use Supabase Edge Function
      // Note: Settings must be synced to KV store manually
      const { getServerUrl: getUrl, getAnonKey, supabase } = await import('./supabase/client');
      const url = getUrl('/api/push/send');
      const anonKey = getAnonKey();
      
      console.log('üì° Calling Edge Function URL:', url);
      console.log('‚ö†Ô∏è Note: OneSignal settings must be synced to KV store for this to work');
      
      // Get auth token
      const { data: { session } } = await supabase.auth.getSession();
      const authToken = session?.access_token;
      
      if (!authToken) {
        throw new Error('Authentication required to send push notifications');
      }
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authToken}`,
          'apikey': anonKey, // Required by Supabase Edge Functions
        },
        body: JSON.stringify({
          title: data.title,
          message: data.message,
          url: data.url,
          icon: data.icon,
          image: data.image,
          data: data.data,
          userIds: options.userIds,
          segments: options.segments,
          tags: options.tags,
          language: options.language,
          store: options.store,
        }),
      });

      const result = await response.json();
      
      if (!response.ok) {
        console.error('‚ùå Edge Function error:', result);
        const errorMessage = result.message || result.error || response.statusText;
        throw new Error(`Edge Function error: ${errorMessage}`);
      }

      console.log('‚úÖ Notification sent successfully:', {
        id: result.id,
        recipients: result.recipients,
      });
      
      return {
        id: result.id,
        recipients: result.recipients,
      };
    } catch (error) {
      console.error('‚ùå Error sending notification:', error);
      return null;
    }
  }

  /**
   * Tag user with custom data
   */
  async tagUser(tags: Record<string, string>): Promise<void> {
    if (!window.OneSignal) {
      await this.initializeSDK();
    }

    try {
      await window.OneSignal.push(['sendTags', tags]);
    } catch (error) {
      console.error('Error tagging user:', error);
    }
  }

  /**
   * Delete user tags
   */
  async deleteUserTags(tagKeys: string[]): Promise<void> {
    if (!window.OneSignal) {
      return;
    }

    try {
      await window.OneSignal.push(['deleteTags', tagKeys]);
    } catch (error) {
      console.error('Error deleting tags:', error);
    }
  }

  /**
   * Send order status notification
   */
  async sendOrderStatusNotification(
    orderNumber: string,
    status: string,
    userId: string,
    language: string = 'ru'
  ): Promise<void> {
    const statusMessages: Record<string, Record<string, { title: string; message: string }>> = {
      pending: {
        ru: {
          title: 'üì¶ –ó–∞–∫–∞–∑ –ø–æ–ª—É—á–µ–Ω',
          message: `–ó–∞–∫–∞–∑ #${orderNumber} –ø—Ä–∏–Ω—è—Ç –≤ –æ–±—Ä–∞–±–æ—Ç–∫—É. –ú—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.`,
        },
        en: {
          title: 'üì¶ Order Received',
          message: `Order #${orderNumber} has been received and is being processed.`,
        },
        zh: {
          title: 'üì¶ ËÆ¢ÂçïÂ∑≤Êî∂Âà∞',
          message: `ËÆ¢Âçï #${orderNumber} Â∑≤Êî∂Âà∞Âπ∂Ê≠£Âú®Â§ÑÁêÜ‰∏≠„ÄÇ`,
        },
        vi: {
          title: 'üì¶ ƒê∆°n h√†ng ƒë√£ nh·∫≠n',
          message: `ƒê∆°n h√†ng #${orderNumber} ƒë√£ ƒë∆∞·ª£c nh·∫≠n v√† ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω.`,
        },
      },
      processing: {
        ru: {
          title: '‚è≥ –ó–∞–∫–∞–∑ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ',
          message: `–ó–∞–∫–∞–∑ #${orderNumber} –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è. –°–∫–æ—Ä–æ –æ–Ω –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.`,
        },
        en: {
          title: '‚è≥ Order Processing',
          message: `Order #${orderNumber} is being processed and will be shipped soon.`,
        },
        zh: {
          title: '‚è≥ ËÆ¢ÂçïÂ§ÑÁêÜ‰∏≠',
          message: `ËÆ¢Âçï #${orderNumber} Ê≠£Âú®Â§ÑÁêÜ‰∏≠ÔºåÂæàÂø´Â∞ÜÂèëË¥ß„ÄÇ`,
        },
        vi: {
          title: '‚è≥ ƒê∆°n h√†ng ƒëang x·ª≠ l√Ω',
          message: `ƒê∆°n h√†ng #${orderNumber} ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω v√† s·∫Ω s·ªõm ƒë∆∞·ª£c g·ª≠i ƒëi.`,
        },
      },
      paid: {
        ru: {
          title: '‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∞',
          message: `–ó–∞–∫–∞–∑ #${orderNumber} –æ–ø–ª–∞—á–µ–Ω. –°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–∫—É–ø–∫—É!`,
        },
        en: {
          title: '‚úÖ Payment Received',
          message: `Order #${orderNumber} has been paid. Thank you for your purchase!`,
        },
        zh: {
          title: '‚úÖ Êî∂Âà∞‰ªòÊ¨æ',
          message: `ËÆ¢Âçï #${orderNumber} Â∑≤‰ªòÊ¨æ„ÄÇÊÑüË∞¢ÊÇ®ÁöÑË¥≠‰π∞ÔºÅ`,
        },
        vi: {
          title: '‚úÖ ƒê√£ nh·∫≠n thanh to√°n',
          message: `ƒê∆°n h√†ng #${orderNumber} ƒë√£ ƒë∆∞·ª£c thanh to√°n. C·∫£m ∆°n b·∫°n ƒë√£ mua h√†ng!`,
        },
      },
      shipped: {
        ru: {
          title: 'üöö –ó–∞–∫–∞–∑ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω',
          message: `–ó–∞–∫–∞–∑ #${orderNumber} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω! –û–∂–∏–¥–∞–π—Ç–µ –¥–æ—Å—Ç–∞–≤–∫—É.`,
        },
        en: {
          title: 'üöö Order Shipped',
          message: `Order #${orderNumber} has been shipped! Expect delivery soon.`,
        },
        zh: {
          title: 'üöö ËÆ¢ÂçïÂ∑≤ÂèëË¥ß',
          message: `ËÆ¢Âçï #${orderNumber} Â∑≤ÂèëË¥ßÔºÅËØ∑Á≠âÂæÖÈÄÅËææ„ÄÇ`,
        },
        vi: {
          title: 'üöö ƒê∆°n h√†ng ƒë√£ g·ª≠i',
          message: `ƒê∆°n h√†ng #${orderNumber} ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒëi! H√£y ch·ªù nh·∫≠n h√†ng.`,
        },
      },
      delivered: {
        ru: {
          title: 'üéâ –ó–∞–∫–∞–∑ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω',
          message: `–ó–∞–∫–∞–∑ #${orderNumber} –¥–æ—Å—Ç–∞–≤–ª–µ–Ω. –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è!`,
        },
        en: {
          title: 'üéâ Order Delivered',
          message: `Order #${orderNumber} has been delivered. Enjoy your purchase!`,
        },
        zh: {
          title: 'üéâ ËÆ¢ÂçïÂ∑≤ÈÄÅËææ',
          message: `ËÆ¢Âçï #${orderNumber} Â∑≤ÈÄÅËææ„ÄÇËØ∑‰∫´ÂèóÊÇ®ÁöÑË¥≠‰π∞ÔºÅ`,
        },
        vi: {
          title: 'üéâ ƒê∆°n h√†ng ƒë√£ giao',
          message: `ƒê∆°n h√†ng #${orderNumber} ƒë√£ ƒë∆∞·ª£c giao. Ch√∫c b·∫°n h√†i l√≤ng!`,
        },
      },
      cancelled: {
        ru: {
          title: '‚ùå –ó–∞–∫–∞–∑ –æ—Ç–º–µ–Ω–µ–Ω',
          message: `–ó–∞–∫–∞–∑ #${orderNumber} –±—ã–ª –æ—Ç–º–µ–Ω–µ–Ω. –°–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏ –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π.`,
        },
        en: {
          title: '‚ùå Order Cancelled',
          message: `Order #${orderNumber} has been cancelled. Contact us for details.`,
        },
        zh: {
          title: '‚ùå ËÆ¢ÂçïÂ∑≤ÂèñÊ∂à',
          message: `ËÆ¢Âçï #${orderNumber} Â∑≤ÂèñÊ∂à„ÄÇËØ∑ËÅîÁ≥ªÊàë‰ª¨‰∫ÜËß£ËØ¶ÊÉÖ„ÄÇ`,
        },
        vi: {
          title: '‚ùå ƒê∆°n h√†ng ƒë√£ h·ªßy',
          message: `ƒê∆°n h√†ng #${orderNumber} ƒë√£ b·ªã h·ªßy. Vui l√≤ng li√™n h·ªá v·ªõi ch√∫ng t√¥i ƒë·ªÉ bi·∫øt chi ti·∫øt.`,
        },
      },
    };

    const statusData = statusMessages[status]?.[language] || statusMessages[status]?.['ru'];
    if (!statusData) {
      console.warn(`No notification template for status: ${status}`);
      return;
    }

    await this.sendNotification(
      {
        title: statusData.title,
        message: statusData.message,
        url: `${window.location.origin}/#profile`,
        data: {
          type: 'order_status',
          orderNumber,
          status,
        },
      },
      {
        userIds: [userId],
      }
    );
  }
}

// Singleton instance
export const oneSignalService = new OneSignalService();

// Type definitions for window.OneSignal
declare global {
  interface Window {
    OneSignal: any;
  }
}
