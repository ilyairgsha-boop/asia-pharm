// Asia-Pharm Server - Edge Function
// Version: 2.0
import { Hono } from 'npm:hono';
import { logger } from 'npm:hono/logger';
import { createClient } from 'npm:@supabase/supabase-js';
import * as kv from './kv_store.tsx';
import { generateOrderEmailHTML, generateOrderEmailText, generateWelcomeEmailHTML } from './email-templates.tsx';

const app = new Hono();

// Custom CORS middleware - set headers explicitly
app.use('*', async (c, next) => {
  // Set CORS headers for all requests
  c.header('Access-Control-Allow-Origin', '*');
  c.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  c.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, apikey, x-client-info');
  c.header('Access-Control-Expose-Headers', 'Content-Length, X-JSON');
  c.header('Access-Control-Max-Age', '86400');
  
  // Handle preflight OPTIONS request
  if (c.req.method === 'OPTIONS') {
    c.status(200);
    return c.body(null);
  }
  
  await next();
});

app.use('*', logger(console.log));

// Supabase clients
const getSupabaseAdmin = () => {
  return createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
  );
};

const getSupabaseClient = () => {
  return createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_ANON_KEY')!
  );
};

// Auth middleware
const requireAuth = async (c: any, next: any) => {
  const authHeader = c.req.header('Authorization');
  if (!authHeader) {
    return c.json({ error: 'Unauthorized' }, 401);
  }

  const token = authHeader.split(' ')[1];
  const supabase = getSupabaseAdmin();
  const { data: { user }, error } = await supabase.auth.getUser(token);

  if (error || !user) {
    return c.json({ error: 'Unauthorized' }, 401);
  }

  c.set('user', user);
  await next();
};

const requireAdmin = async (c: any, next: any) => {
  const authHeader = c.req.header('Authorization');
  if (!authHeader) {
    console.error('‚ùå No Authorization header');
    return c.json({ error: 'Unauthorized - No token provided' }, 401);
  }

  const token = authHeader.split(' ')[1];
  if (!token) {
    console.error('‚ùå Invalid Authorization header format');
    return c.json({ error: 'Unauthorized - Invalid token format' }, 401);
  }

  const supabase = getSupabaseAdmin();
  const { data: { user }, error } = await supabase.auth.getUser(token);

  if (error) {
    console.error('‚ùå Error verifying token:', error);
    return c.json({ error: 'Unauthorized - Invalid token', details: error.message }, 401);
  }

  if (!user) {
    console.error('‚ùå No user found for token');
    return c.json({ error: 'Unauthorized - User not found' }, 401);
  }

  console.log(`‚úÖ User authenticated: ${user.id} (${user.email})`);
  c.set('user', user);
  
  // Check admin status from profiles table
  const { data: profile, error: profileError } = await supabase
    .from('profiles')
    .select('is_admin')
    .eq('id', user.id)
    .maybeSingle();
  
  if (profileError) {
    console.error('‚ùå Error checking admin status:', profileError);
    return c.json({ error: 'Failed to verify admin status', details: profileError.message }, 500);
  }
  
  if (!profile) {
    console.error('‚ùå Profile not found for user:', user.id);
    return c.json({ error: 'Admin access required - Profile not found' }, 403);
  }
  
  if (!profile.is_admin) {
    console.error('‚ùå User is not admin:', user.email);
    return c.json({ error: 'Admin access required' }, 403);
  }
  
  console.log(`‚úÖ Admin access granted: ${user.email}`);
  await next();
};

// Helper function to generate order number in format DDMM + sequence
async function generateOrderNumber(): Promise<string> {
  const now = new Date();
  const day = String(now.getDate()).padStart(2, '0');
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const prefix = `${day}${month}`;
  
  // Get current sequence number
  const seqKey = `order_sequence:${prefix}`;
  let sequence = await kv.get(seqKey);
  
  if (!sequence) {
    sequence = 1;
  } else {
    sequence = sequence + 1;
  }
  
  await kv.set(seqKey, sequence);
  
  // Format: DDMM + 2-digit sequence (e.g., 201001, 201002)
  const orderNumber = `${prefix}${String(sequence).padStart(2, '0')}`;
  return orderNumber;
}

// Helper function to calculate loyalty points with tiered system
function calculateLoyaltyPoints(subtotal: number, totalLifetime: number): number {
  // New loyalty tiers based on lifetime total:
  // 3% for all
  // 5% when total >= 50,000
  // 7% when total >= 100,000
  // 10% when total >= 200,000
  
  let points = 0;
  const previousTotal = totalLifetime - subtotal;
  
  // Tier thresholds
  const tier1 = 50000;   // 3% -> 5%
  const tier2 = 100000;  // 5% -> 7%
  const tier3 = 200000;  // 7% -> 10%
  
  // Calculate points with progressive tiers
  let remaining = subtotal;
  let currentTotal = previousTotal;
  
  while (remaining > 0) {
    let rate = 0.03; // Default 3%
    let nextThreshold = tier1;
    
    if (currentTotal >= tier3) {
      rate = 0.10;
      nextThreshold = Infinity;
    } else if (currentTotal >= tier2) {
      rate = 0.07;
      nextThreshold = tier3;
    } else if (currentTotal >= tier1) {
      rate = 0.05;
      nextThreshold = tier2;
    } else {
      rate = 0.03;
      nextThreshold = tier1;
    }
    
    // Calculate amount at current rate
    const amountAtRate = Math.min(remaining, nextThreshold - currentTotal);
    points += Math.floor(amountAtRate * rate);
    
    remaining -= amountAtRate;
    currentTotal += amountAtRate;
  }
  
  return points;
}

// Helper function to update user loyalty points
async function updateUserLoyalty(userId: string, points: number, type: 'earned' | 'spent', description: string) {
  try {
    // Get current user loyalty data
    const userLoyaltyKey = `user_loyalty:${userId}`;
    let loyaltyData = await kv.get(userLoyaltyKey);
    
    if (!loyaltyData) {
      loyaltyData = {
        userId,
        points: 0,
        totalEarned: 0,
        totalSpent: 0,
        history: []
      };
    }
    
    // Update points
    if (type === 'earned') {
      loyaltyData.points += points;
      loyaltyData.totalEarned += points;
    } else {
      loyaltyData.points -= points;
      loyaltyData.totalSpent += points;
    }
    
    // Add to history
    loyaltyData.history.unshift({
      id: crypto.randomUUID(),
      points,
      type,
      description,
      createdAt: new Date().toISOString()
    });
    
    // Keep only last 100 history items
    if (loyaltyData.history.length > 100) {
      loyaltyData.history = loyaltyData.history.slice(0, 100);
    }
    
    await kv.set(userLoyaltyKey, loyaltyData);
    return loyaltyData;
  } catch (error) {
    console.error('Error updating user loyalty:', error);
    throw error;
  }
}

// Helper function to get user's LIFETIME order total (NEW LOYALTY SYSTEM)
async function getUserLifetimeTotal(userId: string): Promise<number> {
  try {
    console.log(`üìä Calculating LIFETIME total for user: ${userId}`);
    
    // Get all user orders
    const userOrders = await kv.getByPrefix(`user_order:${userId}:`);
    console.log(`üì¶ Found ${userOrders.length} user orders`);
    
    let lifetimeTotal = 0;
    
    for (const userOrder of userOrders) {
      const orderId = userOrder.value;
      const order = await kv.get(`order:${orderId}`);
      
      if (order && order.status === 'delivered') {
        const orderTotal = order.subtotal || order.totalPrice || 0;
        lifetimeTotal += orderTotal;
        console.log(`‚úÖ Added ${orderTotal} ‚ÇΩ to lifetime total (Order #${order.orderNumber || orderId.slice(0, 6)})`);
      }
    }
    
    console.log(`üíé FINAL LIFETIME TOTAL: ${lifetimeTotal} ‚ÇΩ`);
    return lifetimeTotal;
  } catch (error) {
    console.error('‚ùå Error calculating lifetime total:', error);
    return 0;
  }
}

// DEPRECATED: Old monthly function - redirects to lifetime
async function getUserMonthlyTotal(userId: string): Promise<number> {
  console.log('‚ö†Ô∏è getUserMonthlyTotal is deprecated, using getUserLifetimeTotal instead');
  return getUserLifetimeTotal(userId);
}

// Helper function to send welcome email after registration
async function sendWelcomeEmail(email: string, userData: any) {
  try {
    const emailSettings = await kv.get('setting:email');
    
    // Check if email is explicitly disabled (but allow if settings don't exist)
    if (emailSettings && emailSettings.enabled === false) {
      console.log('üìß Email sending is disabled in settings');
      return { success: false, message: 'Email disabled' };
    }

    const language = userData.language || 'ru';
    const welcomeHTML = generateWelcomeEmailHTML(userData, language);
    
    const subjects = {
      ru: '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –Ω–∞ —Å–∞–π—Ç –ê–∑–∏—è –§–∞—Ä–º!',
      en: 'Welcome to Asia Pharm!',
      zh: 'Ê¨¢ËøéÊù•Âà∞‰∫öÊ¥≤ËçØÊàøÔºÅ',
      vi: 'Ch√†o m·ª´ng ƒë·∫øn v·ªõi Asia Pharm!'
    };

    console.log(`üìß Sending welcome email to ${email} (language: ${language})`);

    const response = await fetch('https://api.resend.com/emails', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${Deno.env.get('RESEND_API_KEY')}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        from: emailSettings?.from || 'Asia Pharm <info@asia-pharm.com>',
        to: [email],
        subject: subjects[language] || subjects.ru,
        html: welcomeHTML,
      }),
    });

    if (response.ok) {
      const data = await response.json();
      console.log('‚úÖ Welcome email sent successfully:', data.id);
      return { success: true, emailId: data.id };
    } else {
      const error = await response.text();
      console.error('‚ùå Failed to send welcome email:', error);
      return { success: false, error };
    }
  } catch (error) {
    console.error('‚ùå Exception sending welcome email:', error);
    return { success: false, error: String(error) };
  }
}

// Helper function to send order emails with professional HTML template
async function sendOrderEmail(email: string, order: any, type: 'new' | 'status_update' | 'tracking') {
  try {
    // Get email settings from KV store
    const emailSettings = await kv.get('setting:email');
    
    // Get payment settings for QR code
    const paymentSettings = await kv.get('setting:payment');
    
    // Check if email notifications are enabled
    if (!emailSettings) {
      console.log('‚ö†Ô∏è Email settings not configured, skipping email notification');
      return { success: false, reason: 'Email settings not configured' };
    }

    // Check if this type of notification is enabled
    const notificationTypeMap = {
      'new': 'sendOrderConfirmation',
      'status_update': 'sendShippingNotification',
      'tracking': 'sendShippingNotification',
    };
    
    const notificationType = notificationTypeMap[type];
    if (notificationType && !emailSettings[notificationType]) {
      console.log(`‚ö†Ô∏è ${type} email notifications are disabled`);
      return { success: false, reason: 'Notification type disabled' };
    }

    const orderNum = order.orderNumber || order.id.slice(0, 6);

    // Map type to status - use order.status directly when available
    let status: 'pending' | 'processing' | 'shipped' | 'delivered' | 'cancelled' = 'pending';
    
    if (type === 'new') {
      status = 'pending';
    } else if (type === 'tracking') {
      status = 'shipped';
    } else if (type === 'status_update') {
      // Use the actual order status for status updates
      const orderStatus = order.status?.toLowerCase();
      if (orderStatus === 'delivered' || orderStatus === '–¥–æ—Å—Ç–∞–≤–ª–µ–Ω') {
        status = 'delivered';
      } else if (orderStatus === 'shipped' || orderStatus === '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω') {
        status = 'shipped';
      } else if (orderStatus === 'cancelled' || orderStatus === '–æ—Ç–º–µ–Ω–µ–Ω') {
        status = 'cancelled';
      } else if (orderStatus === 'processing' || orderStatus === '–≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ') {
        status = 'processing';
      } else {
        status = 'processing'; // default for status_update
      }
    }

    // Calculate loyalty points correctly based on user's lifetime total
    let calculatedLoyaltyPoints = 0;
    if (order.userId && (status === 'pending' || status === 'processing')) {
      try {
        // Get all user orders for lifetime total
        const userOrderKeys = await kv.getByPrefix(`user_order:${order.userId}:`);
        let lifetimeTotal = 0;
        
        for (const key of userOrderKeys) {
          const orderId = key.value;
          const userOrder = await kv.get(`order:${orderId}`);
          if (userOrder && userOrder.status !== 'cancelled') {
            lifetimeTotal += (userOrder.subtotalWithoutSamples || userOrder.subtotal || 0);
          }
        }
        
        // Use the calculateLoyaltyPoints function with lifetime total
        calculatedLoyaltyPoints = calculateLoyaltyPoints(
          order.subtotalWithoutSamples || order.subtotal || 0,
          lifetimeTotal
        );
      } catch (error) {
        console.error('‚ùå Error calculating loyalty points:', error);
        // Fallback to 3% if calculation fails
        calculatedLoyaltyPoints = Math.floor((order.subtotalWithoutSamples || order.subtotal || 0) * 0.03);
      }
    }
    
    // Prepare email data
    const emailData = {
      orderId: orderNum,
      orderDate: order.createdAt || new Date().toISOString(),
      customerName: order.customerName || order.shippingAddress?.fullName || '–ö–ª–∏–µ–Ω—Ç',
      status: status,
      items: order.items?.map((item: any) => ({
        id: item.id || item.productId,
        name: item.name,
        quantity: item.quantity,
        price: item.price,
        image: item.image,
        total: item.quantity * item.price
      })) || [],
      deliveryMethod: order.deliveryMethod || order.shippingInfo?.deliveryMethod || '–ù–µ —É–∫–∞–∑–∞–Ω',
      deliveryCost: order.shippingCost || 0,
      totalAmount: order.totalPrice || 0,
      shippingAddress: {
        fullName: order.shippingAddress?.fullName || order.customerName || '',
        address: order.shippingAddress?.address || ''
      },
      paymentMethod: order.paymentMethod,
      promoCode: order.promoCode,
      promoDiscount: order.promoDiscount || 0,
      loyaltyPointsUsed: order.loyaltyPointsUsed || 0,
      loyaltyPointsEarned: order.loyaltyPointsEarned || calculatedLoyaltyPoints,
      currentLoyaltyBalance: order.currentLoyaltyBalance || 0,
      trackingNumber: order.trackingNumber,
      trackingUrl: order.trackingNumber ? `https://asia-pharm.com/orders?track=${order.trackingNumber}` : undefined,
      paymentDetails: {
        cardNumber: paymentSettings?.cardNumber || '2202 2004 3395 7386',
        contractNumber: paymentSettings?.contractNumber || '505 518 5408',
        qrCodeUrl: paymentSettings?.qrCodeUrl || null
      }
    };

    // Get user language (default to Russian)
    const language = order.language || 'ru';

    // Generate HTML and text versions
    const htmlMessage = generateOrderEmailHTML(emailData, language);
    const textMessage = generateOrderEmailText(emailData, language);

    // Prepare subject based on status
    const subjects = {
      ru: {
        pending: `–ó–∞–∫–∞–∑ #${orderNum} –ø—Ä–∏–Ω—è—Ç - –ê–∑–∏—è –§–∞—Ä–º`,
        processing: `–ó–∞–∫–∞–∑ #${orderNum} –æ–ø–ª–∞—á–µ–Ω - –ê–∑–∏—è –§–∞—Ä–º`,
        shipped: `–ó–∞–∫–∞–∑ #${orderNum} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω - –ê–∑–∏—è –§–∞—Ä–º`,
        delivered: `–ó–∞–∫–∞–∑ #${orderNum} –¥–æ—Å—Ç–∞–≤–ª–µ–Ω - –ê–∑–∏—è –§–∞—Ä–º`,
        cancelled: `–ó–∞–∫–∞–∑ #${orderNum} –æ—Ç–º–µ–Ω–µ–Ω - –ê–∑–∏—è –§–∞—Ä–º`
      },
      en: {
        pending: `Order #${orderNum} received - Asia Pharm`,
        processing: `Order #${orderNum} paid - Asia Pharm`,
        shipped: `Order #${orderNum} shipped - Asia Pharm`,
        delivered: `Order #${orderNum} delivered - Asia Pharm`,
        cancelled: `Order #${orderNum} cancelled - Asia Pharm`
      },
      zh: {
        pending: `ËÆ¢Âçï #${orderNum} Â∑≤Êî∂Âà∞ - ‰∫öÊ¥≤ËçØÊàø`,
        processing: `ËÆ¢Âçï #${orderNum} Â∑≤‰ªòÊ¨æ - ‰∫öÊ¥≤ËçØÊàø`,
        shipped: `ËÆ¢Âçï #${orderNum} Â∑≤ÂèëË¥ß - ‰∫öÊ¥≤ËçØÊàø`,
        delivered: `ËÆ¢Âçï #${orderNum} Â∑≤ÈÄÅËææ - ‰∫öÊ¥≤ËçØÊàø`,
        cancelled: `ËÆ¢Âçï #${orderNum} Â∑≤ÂèñÊ∂à - ‰∫öÊ¥≤ËçØÊàø`
      },
      vi: {
        pending: `ƒê∆°n h√†ng #${orderNum} ƒë√£ nh·∫≠n - Asia Pharm`,
        processing: `ƒê∆°n h√†ng #${orderNum} ƒë√£ thanh to√°n - Asia Pharm`,
        shipped: `ƒê∆°n h√†ng #${orderNum} ƒë√£ g·ª≠i - Asia Pharm`,
        delivered: `ƒê∆°n h√†ng #${orderNum} ƒë√£ giao - Asia Pharm`,
        cancelled: `ƒê∆°n h√†ng #${orderNum} ƒë√£ h·ªßy - Asia Pharm`
      }
    };

    const subject = subjects[language as keyof typeof subjects]?.[status] || subjects.ru[status];

    console.log(`üìß Sending ${type} email to ${email} (order ${orderNum}, status: ${status})`);

    // Send email using Resend API
    try {
      const resendApiKey = Deno.env.get('RESEND_API_KEY');
      
      if (!resendApiKey) {
        console.error('‚ùå RESEND_API_KEY not configured in environment variables');
        console.log('üì® Email Details (not sent):');
        console.log(`   To: ${email}`);
        console.log(`   Subject: ${subject}`);
        return { success: false, reason: 'RESEND_API_KEY not configured' };
      }

      // Prepare from email - Resend requires format: "Name <email@domain.com>"
      const fromEmailAddress = emailSettings.smtpUser || 'info@asia-pharm.com';
      const fromName = emailSettings.fromName || '–ê–∑–∏—è –§–∞—Ä–º';
      const fromEmail = `${fromName} <${fromEmailAddress}>`;
      
      console.log(`üì® Sending via Resend API:`);
      console.log(`   To: ${email}`);
      console.log(`   From: ${fromEmail}`);
      console.log(`   Subject: ${subject}`);
      console.log(`   Language: ${language}`);
      console.log(`   Status: ${status}`);
      
      // Send email via Resend REST API
      const response = await fetch('https://api.resend.com/emails', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${resendApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          from: fromEmail,
          to: [email],
          subject: subject,
          html: htmlMessage,
          text: textMessage,
        }),
      });

      if (!response.ok) {
        const errorData = await response.text();
        console.error(`‚ùå Resend API error (${response.status}):`, errorData);
        return { success: false, error: `Resend API returned ${response.status}` };
      }

      const result = await response.json();
      console.log('‚úÖ Email sent successfully via Resend:', result.id);
      return { success: true, emailId: result.id };
      
    } catch (sendError) {
      console.error('‚ùå Failed to send email:', sendError);
      return { success: false, error: sendError };
    }
  } catch (error) {
    console.error('‚ùå Email error:', error);
    return { success: false, error };
  }
}

// Routes

// Health check
app.get('/', (c) => {
  return c.json({ status: 'OK', message: 'Asia-Pharm Store API' });
});

// ============================================
// PUBLIC ENDPOINTS (NO AUTH REQUIRED)
// MUST BE DEFINED BEFORE ALL OTHER ROUTES
// ============================================

// Get chat settings (public - no auth required)
app.get('/public/settings/chat', async (c) => {
  try {
    console.log('üìã [PUBLIC] Fetching chat settings - NO AUTH REQUIRED');
    console.log('üìã Headers:', {
      authorization: c.req.header('authorization'),
      apikey: c.req.header('apikey'),
    });
    
    const value = await kv.get('setting:chat');
    
    if (!value) {
      // Return default settings if not configured
      console.log('üìã Returning default chat settings');
      return c.json({ 
        value: {
          enabled: true,
          telegram: '@asiapharm',
          whatsapp: '+79001234567',
        }
      });
    }
    
    console.log('‚úÖ Chat settings found and returned');
    return c.json({ value });
  } catch (error) {
    console.error('‚ùå Error fetching chat settings:', error);
    // Return defaults on error
    return c.json({ 
      value: {
        enabled: true,
        telegram: '@asiapharm',
        whatsapp: '+79001234567',
      }
    });
  }
});

// Get payment settings (public - no auth required)
app.get('/payment-settings', async (c) => {
  try {
    console.log('üìã [PUBLIC] Fetching payment settings for display - NO AUTH REQUIRED');
    console.log('üìã Headers:', {
      authorization: c.req.header('authorization'),
      apikey: c.req.header('apikey'),
    });
    
    const value = await kv.get('setting:payment');
    
    if (value === null || value === undefined) {
      console.log('‚ö†Ô∏è Payment settings not found in DB, returning defaults');
      return c.json({ 
        value: {
          cardNumber: "2202 2004 3395 7386",
          contractNumber: "505 518 5408",
          qrCodeUrl: null
        }
      });
    }
    
    console.log('‚úÖ Payment settings loaded for public view');
    return c.json({ value });
  } catch (error) {
    console.error('‚ùå Error fetching payment settings:', error);
    // Return defaults on error
    return c.json({ 
      value: {
        cardNumber: "2202 2004 3395 7386",
        contractNumber: "505 518 5408",
        qrCodeUrl: null
      }
    });
  }
});

// ============================================
// AUTHENTICATED ENDPOINTS
// ============================================

// Sign up
app.post('/signup', async (c) => {
  try {
    const { email, password, name, language } = await c.req.json();
    const supabase = getSupabaseAdmin();

    console.log(`üë§ Creating user account for: ${email}`);

    // Create user in auth
    const { data, error } = await supabase.auth.admin.createUser({
      email,
      password,
      user_metadata: { name },
      email_confirm: true, // Auto-confirm email
    });

    if (error) {
      console.error('‚ùå Signup auth error:', error);
      return c.json({ error: error.message }, 400);
    }

    console.log(`‚úÖ Auth user created: ${data.user.id}`);

    // Create profile in database
    const { error: profileError } = await supabase
      .from('profiles')
      .insert([{
        id: data.user.id,
        email: email,
        name: name,
        is_admin: false,
        is_wholesaler: false,
        loyalty_points: 0,
        loyalty_tier: 'basic',
        monthly_total: 0,
      }]);

    if (profileError) {
      console.error('‚ùå Profile creation error:', profileError);
      // Try to check if profile already exists
      const { data: existingProfile } = await supabase
        .from('profiles')
        .select('id')
        .eq('id', data.user.id)
        .single();
      
      if (existingProfile) {
        console.log('‚ÑπÔ∏è Profile already exists for user');
      } else {
        console.error('‚ö†Ô∏è Failed to create profile, but user auth was created');
      }
    } else {
      console.log(`‚úÖ Profile created successfully for user: ${data.user.id}`);
    }

    // Send welcome email
    try {
      await sendWelcomeEmail(email, {
        name: name,
        email: email,
        password: password,
        language: language || 'ru'
      });
      console.log('‚úÖ Welcome email sent');
    } catch (emailError) {
      console.error('‚ö†Ô∏è Failed to send welcome email:', emailError);
      // Don't fail registration if email fails
    }

    return c.json({ success: true, user: data.user });
  } catch (error) {
    console.error('‚ùå Signup exception:', error);
    return c.json({ error: 'Registration failed', details: String(error) }, 500);
  }
});

// Get all products
app.get('/products', async (c) => {
  try {
    const supabase = getSupabaseClient();
    
    const { data: products, error } = await supabase
      .from('products')
      .select('*')
      .eq('in_stock', true)
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error('‚ùå Error fetching products:', error);
      return c.json({ error: 'Failed to fetch products', details: error.message }, 500);
    }
    
    // Map products from DB format to frontend format
    const mappedProducts = (products || []).map(mapProductFromDb);
    
    console.log(`‚úÖ Fetched ${mappedProducts.length} products`);
    return c.json({ products: mappedProducts });
  } catch (error) {
    console.error('‚ùå Exception fetching products:', error);
    return c.json({ error: 'Failed to fetch products', details: String(error) }, 500);
  }
});

// Helper function to map DB format to frontend fields
const mapProductFromDb = (dbProduct: any) => {
  const frontendData: any = { ...dbProduct };
  
  // Map snake_case to camelCase for shortDescription fields
  if ('short_description' in frontendData) {
    frontendData.shortDescription = frontendData.short_description || '';
  }
  if ('short_description_en' in frontendData) {
    frontendData.shortDescription_en = frontendData.short_description_en || '';
  }
  if ('short_description_zh' in frontendData) {
    frontendData.shortDescription_zh = frontendData.short_description_zh || '';
  }
  if ('short_description_vi' in frontendData) {
    frontendData.shortDescription_vi = frontendData.short_description_vi || '';
  }
  
  // Map snake_case to camelCase for diseaseCategories
  if ('disease_categories' in frontendData) {
    // Ensure diseaseCategories is always an array
    const categories = frontendData.disease_categories;
    if (Array.isArray(categories)) {
      frontendData.diseaseCategories = categories;
    } else if (typeof categories === 'string') {
      // Handle case where it might be a JSON string
      try {
        frontendData.diseaseCategories = JSON.parse(categories);
      } catch {
        frontendData.diseaseCategories = [categories];
      }
    } else {
      frontendData.diseaseCategories = [];
    }
  } else if (!frontendData.diseaseCategories && frontendData.disease) {
    // Fallback: if diseaseCategories is missing, use disease field
    frontendData.diseaseCategories = [frontendData.disease];
  } else if (!frontendData.diseaseCategories) {
    // Ensure diseaseCategories always exists
    frontendData.diseaseCategories = [];
  }
  
  return frontendData;
};

// Helper function to map frontend fields to DB format
const mapProductToDb = (productData: any) => {
  const dbData: any = { ...productData };
  
  // Map camelCase to snake_case for shortDescription fields
  if ('shortDescription' in dbData) {
    dbData.short_description = dbData.shortDescription;
    delete dbData.shortDescription;
  }
  if ('shortDescription_en' in dbData) {
    dbData.short_description_en = dbData.shortDescription_en;
    delete dbData.shortDescription_en;
  }
  if ('shortDescription_zh' in dbData) {
    dbData.short_description_zh = dbData.shortDescription_zh;
    delete dbData.shortDescription_zh;
  }
  if ('shortDescription_vi' in dbData) {
    dbData.short_description_vi = dbData.shortDescription_vi;
    delete dbData.shortDescription_vi;
  }
  
  // Map camelCase to snake_case for diseaseCategories
  if ('diseaseCategories' in dbData) {
    dbData.disease_categories = dbData.diseaseCategories;
    delete dbData.diseaseCategories;
  }
  
  return dbData;
};

// Create product (admin only)
app.post('/products', requireAdmin, async (c) => {
  try {
    const productData = await c.req.json();
    
    console.log('üì¶ Creating product with data:', JSON.stringify(productData, null, 2));
    console.log('üîê SUPABASE_URL:', Deno.env.get('SUPABASE_URL'));
    console.log('üîë SERVICE_ROLE_KEY exists:', !!Deno.env.get('SUPABASE_SERVICE_ROLE_KEY'));
    
    // Validate required fields
    const requiredFields = ['name', 'name_en', 'name_zh', 'name_vi', 'price', 'category', 'disease', 'store'];
    const missingFields = requiredFields.filter(field => !productData[field]);
    
    if (missingFields.length > 0) {
      console.error('‚ùå Missing required fields:', missingFields);
      return c.json({ 
        error: 'Missing required fields', 
        details: `Required fields: ${missingFields.join(', ')}` 
      }, 400);
    }
    
    // Map fields to DB format
    const dbData = mapProductToDb(productData);
    
    const supabase = getSupabaseAdmin();
    
    console.log('üóÑÔ∏è Attempting to insert into products table...');
    
    const { data: product, error } = await supabase
      .from('products')
      .insert([dbData])
      .select()
      .single();
    
    if (error) {
      console.error('‚ùå Error creating product in DB:', error);
      console.error('‚ùå Error details:', JSON.stringify(error, null, 2));
      console.error('‚ùå Error code:', error.code);
      console.error('‚ùå Error message:', error.message);
      console.error('‚ùå Error hint:', error.hint);
      return c.json({ 
        error: 'Failed to create product', 
        details: error.message,
        hint: error.hint,
        code: error.code 
      }, 500);
    }
    
    console.log('‚úÖ Product created successfully:', product.id);
    // Map product back to frontend format
    const mappedProduct = mapProductFromDb(product);
    return c.json({ success: true, product: mappedProduct });
  } catch (error) {
    console.error('‚ùå Exception creating product:', error);
    console.error('‚ùå Exception type:', typeof error);
    console.error('‚ùå Exception stack:', error instanceof Error ? error.stack : 'N/A');
    return c.json({ error: 'Failed to create product', details: String(error) }, 500);
  }
});

// Update product (admin only)
app.put('/products/:id', requireAdmin, async (c) => {
  try {
    const productId = c.req.param('id');
    const productData = await c.req.json();
    const supabase = getSupabaseAdmin();
    
    console.log(`üìù Updating product ${productId} with data:`, JSON.stringify(productData, null, 2));

    // Remove id from productData if it exists (can't update id)
    const { id, ...dataWithoutId } = productData;
    
    // Map fields to DB format
    const updateData = mapProductToDb(dataWithoutId);
    
    console.log(`üìù Update data after mapping:`, JSON.stringify(updateData, null, 2));

    const { data: product, error } = await supabase
      .from('products')
      .update(updateData)
      .eq('id', productId)
      .select()
      .single();
    
    if (error) {
      console.error('‚ùå Error updating product in DB:', error);
      console.error('‚ùå Error details:', JSON.stringify(error, null, 2));
      console.error('‚ùå Error code:', error.code);
      console.error('‚ùå Error message:', error.message);
      return c.json({ 
        error: 'Failed to update product', 
        details: error.message,
        code: error.code,
        hint: error.hint 
      }, 500);
    }
    
    console.log('‚úÖ Product updated successfully:', product.id);
    // Map product back to frontend format
    const mappedProduct = mapProductFromDb(product);
    return c.json({ success: true, product: mappedProduct });
  } catch (error) {
    console.error('‚ùå Exception updating product:', error);
    console.error('‚ùå Exception stack:', error instanceof Error ? error.stack : 'N/A');
    return c.json({ error: 'Failed to update product', details: String(error) }, 500);
  }
});

// Delete product (admin only)
app.delete('/products/:id', requireAdmin, async (c) => {
  try {
    const productId = c.req.param('id');
    const supabase = getSupabaseAdmin();
    
    console.log(`üóëÔ∏è Deleting product ${productId}`);
    
    const { error } = await supabase
      .from('products')
      .delete()
      .eq('id', productId);
    
    if (error) {
      console.error('‚ùå Error deleting product from DB:', error);
      return c.json({ error: 'Failed to delete product', details: error.message }, 500);
    }
    
    console.log('‚úÖ Product deleted successfully');
    return c.json({ success: true });
  } catch (error) {
    console.error('‚ùå Exception deleting product:', error);
    return c.json({ error: 'Failed to delete product', details: String(error) }, 500);
  }
});

// ============================================
// User Management Endpoints
// ============================================

// Get all users (admin only)
app.get('/make-server-a75b5353/admin/users', requireAdmin, async (c) => {
  try {
    const supabase = getSupabaseAdmin();
    
    console.log('üë• Fetching all users...');
    
    const { data: profiles, error } = await supabase
      .from('profiles')
      .select('id, email, name, is_admin, is_wholesaler, created_at')
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error('‚ùå Error fetching users:', error);
      return c.json({ error: 'Failed to fetch users', details: error.message }, 500);
    }
    
    // Map to frontend format
    const users = profiles.map(p => ({
      id: p.id,
      email: p.email,
      name: p.name,
      isAdmin: p.is_admin,
      isWholesaler: p.is_wholesaler,
      createdAt: p.created_at,
    }));
    
    console.log(`‚úÖ Fetched ${users.length} users`);
    return c.json({ users });
  } catch (error) {
    console.error('‚ùå Exception fetching users:', error);
    return c.json({ error: 'Failed to fetch users', details: String(error) }, 500);
  }
});

// Update user wholesaler status (admin only)
app.put('/make-server-a75b5353/admin/users/:id/wholesaler', requireAdmin, async (c) => {
  try {
    const userId = c.req.param('id');
    const { isWholesaler } = await c.req.json();
    const supabase = getSupabaseAdmin();
    
    console.log(`üë§ Updating wholesaler status for user ${userId} to ${isWholesaler}`);
    
    const { error } = await supabase
      .from('profiles')
      .update({ is_wholesaler: isWholesaler })
      .eq('id', userId);
    
    if (error) {
      console.error('‚ùå Error updating wholesaler status:', error);
      return c.json({ error: 'Failed to update user', details: error.message }, 500);
    }
    
    console.log('‚úÖ Wholesaler status updated successfully');
    return c.json({ success: true });
  } catch (error) {
    console.error('‚ùå Exception updating wholesaler status:', error);
    return c.json({ error: 'Failed to update user', details: String(error) }, 500);
  }
});

// Create order
app.post('/make-server-a75b5353/orders', requireAuth, async (c) => {
  try {
    const user = c.get('user');
    const { items, store, shippingInfo, subtotal, subtotalWithoutSamples, shippingCost, promoCode, promoDiscount, loyaltyPointsUsed, totalPrice, language } = await c.req.json();
    
    const orderId = crypto.randomUUID();
    const orderNumber = await generateOrderNumber();
    
    const order = {
      id: orderId,
      orderNumber,
      userId: user.id,
      userEmail: user.email,
      customerName: shippingInfo?.fullName || user.name || '–ö–ª–∏–µ–Ω—Ç',
      language: language || 'ru', // Save user's language preference for emails
      items,
      store,
      shippingInfo,
      shippingAddress: {
        fullName: shippingInfo?.fullName || user.name || '',
        address: [shippingInfo?.region, shippingInfo?.city, shippingInfo?.address].filter(Boolean).join(', ')
      },
      deliveryMethod: shippingInfo?.deliveryMethod || '–ù–µ —É–∫–∞–∑–∞–Ω',
      subtotal: subtotal || totalPrice,
      subtotalWithoutSamples: subtotalWithoutSamples || subtotal || totalPrice,
      shippingCost: shippingCost || 0,
      promoCode: promoCode || null,
      promoDiscount: promoDiscount || 0,
      loyaltyPointsUsed: loyaltyPointsUsed || 0,
      totalPrice,
      status: 'pending',
      createdAt: new Date().toISOString(),
      orderDate: new Date().toISOString(),
    };

    await kv.set(`order:${orderId}`, order);
    await kv.set(`user_order:${user.id}:${orderId}`, orderId);
    
    // If loyalty points were used, deduct them
    if (loyaltyPointsUsed && loyaltyPointsUsed > 0) {
      await updateUserLoyalty(user.id, loyaltyPointsUsed, 'spent', `–ò—Å–ø–æ–ª—å–∑–æ–≤–∞ÔøΩÔøΩ–æ –ø—Ä–∏ –∑–∞–∫–∞–∑–µ #${orderNumber}`);
    }

    // Send email notification
    try {
      console.log(`üìß Attempting to send order confirmation email to ${user.email} for order #${orderNumber}`);
      const emailResult = await sendOrderEmail(user.email, order, 'new');
      console.log('üìß Email result:', emailResult);
    } catch (emailError) {
      console.error('‚ùå Email send error:', emailError);
    }

    return c.json({ success: true, orderId, orderNumber, order });
  } catch (error) {
    console.error('Error creating order:', error);
    return c.json({ error: 'Failed to create order' }, 500);
  }
});

// Get user's orders
app.get('/make-server-a75b5353/orders', requireAuth, async (c) => {
  try {
    const user = c.get('user');
    const userOrders = await kv.getByPrefix(`user_order:${user.id}:`);
    
    const orders = [];
    for (const userOrder of userOrders) {
      const orderId = userOrder.value;
      const order = await kv.get(`order:${orderId}`);
      if (order) {
        orders.push(order);
      }
    }

    orders.sort((a, b) => new Date(b.createdAt || b.orderDate).getTime() - new Date(a.createdAt || a.orderDate).getTime());
    return c.json({ orders });
  } catch (error) {
    console.error('Error fetching orders:', error);
    return c.json({ error: 'Failed to fetch orders' }, 500);
  }
});

// Get all orders (admin only)
app.get('/make-server-a75b5353/admin/orders', requireAdmin, async (c) => {
  try {
    const orders = await kv.getByPrefix('order:');
    const orderList = orders.map(o => o.value);
    orderList.sort((a, b) => new Date(b.createdAt || b.orderDate).getTime() - new Date(a.createdAt || a.orderDate).getTime());
    
    return c.json({ orders: orderList });
  } catch (error) {
    console.error('Error fetching orders:', error);
    return c.json({ error: 'Failed to fetch orders' }, 500);
  }
});

// Update order status (admin only)
app.put('/make-server-a75b5353/admin/orders/:id/status', requireAdmin, async (c) => {
  try {
    const orderId = c.req.param('id');
    const { status } = await c.req.json();

    console.log(`üìù Updating order ${orderId} to status: ${status}`);

    const order = await kv.get(`order:${orderId}`);
    if (!order) {
      console.error(`‚ùå Order not found: ${orderId}`);
      return c.json({ error: 'Order not found' }, 404);
    }

    const oldStatus = order.status;
    order.status = status;
    await kv.set(`order:${orderId}`, order);
    
    console.log(`‚úÖ Order status updated from ${oldStatus} to ${status}`);
    
    // If order status changed to 'delivered', award loyalty points
    if (status === 'delivered' && oldStatus !== 'delivered') {
      try {
        console.log(`üéÅ Awarding loyalty points for order ${orderId}`);
        
        // Get LIFETIME total (not monthly) for new loyalty system
        const lifetimeTotal = await getUserLifetimeTotal(order.userId);
        const orderAmount = order.subtotal || order.totalPrice || 0;
        const newLifetimeTotal = lifetimeTotal + orderAmount;
        
        // Calculate points with progressive tiers based on LIFETIME total
        const points = calculateLoyaltyPoints(orderAmount, newLifetimeTotal);
        
        console.log(`üíé Calculated ${points} loyalty points`);
        console.log(`   Previous lifetime: ${lifetimeTotal} ‚ÇΩ`);
        console.log(`   Order amount: ${orderAmount} ‚ÇΩ`);
        console.log(`   New lifetime: ${newLifetimeTotal} ‚ÇΩ`);
        
        if (points > 0) {
          await updateUserLoyalty(order.userId, points, 'earned', `–ù–∞—á–∏—Å–ª–µ–Ω–æ –∑–∞ –∑–∞–∫–∞–∑ #${order.orderNumber || order.id.slice(0, 6)}`);
          console.log(`‚úÖ Awarded ${points} loyalty points to user ${order.userId} for order #${order.orderNumber}`);
        }
      } catch (loyaltyError) {
        console.error('‚ùå Error awarding loyalty points:', loyaltyError);
        // Don't fail the whole operation, just log the error
      }
    }

    // Send email notification
    try {
      await sendOrderEmail(order.userEmail, order, 'status_update');
    } catch (emailError) {
      console.error('‚ùå Email send error:', emailError);
      // Don't fail the whole operation, just log the error
    }

    console.log(`‚úÖ Order status update complete for ${orderId}`);
    return c.json({ success: true, order });
  } catch (error) {
    console.error('‚ùå Exception updating order status:', error);
    console.error('‚ùå Error details:', error instanceof Error ? error.message : String(error));
    console.error('‚ùå Error stack:', error instanceof Error ? error.stack : 'N/A');
    return c.json({ error: 'Failed to update order status', details: String(error) }, 500);
  }
});

// Send tracking number (admin only)
app.put('/make-server-a75b5353/admin/orders/:id/tracking', requireAdmin, async (c) => {
  try {
    const orderId = c.req.param('id');
    const { trackingNumber } = await c.req.json();

    const order = await kv.get(`order:${orderId}`);
    if (!order) {
      return c.json({ error: 'Order not found' }, 404);
    }

    order.trackingNumber = trackingNumber;
    order.status = 'shipped';
    await kv.set(`order:${orderId}`, order);

    // Send email notification with tracking number
    try {
      await sendOrderEmail(order.userEmail, order, 'tracking');
    } catch (emailError) {
      console.error('Email send error:', emailError);
    }

    return c.json({ success: true, order });
  } catch (error) {
    console.error('Error sending tracking number:', error);
    return c.json({ error: 'Failed to send tracking number' }, 500);
  }
});

// Get user loyalty info (both /loyalty and /loyalty/info for compatibility)
app.get('/make-server-a75b5353/loyalty', requireAuth, async (c) => {
  try {
    const user = c.get('user');
    const userLoyaltyKey = `user_loyalty:${user.id}`;
    let loyaltyData = await kv.get(userLoyaltyKey);
    
    if (!loyaltyData) {
      loyaltyData = {
        userId: user.id,
        points: 0,
        totalEarned: 0,
        totalSpent: 0,
        history: []
      };
    }
    
    // Calculate lifetime total for new progressive system
    const lifetimeTotal = await getUserLifetimeTotal(user.id);
    
    // Determine tier based on lifetime total
    let tier: 'basic' | 'silver' | 'gold' | 'platinum' = 'basic';
    if (lifetimeTotal >= 200000) {
      tier = 'platinum'; // 10%
    } else if (lifetimeTotal >= 100000) {
      tier = 'gold'; // 7%
    } else if (lifetimeTotal >= 50000) {
      tier = 'silver'; // 5%
    } else {
      tier = 'basic'; // 3%
    }
    
    // Also calculate monthly total for backward compatibility
    const monthlyTotal = await getUserMonthlyTotal(user.id);
    
    return c.json({
      points: loyaltyData.points,
      totalEarned: loyaltyData.totalEarned,
      totalSpent: loyaltyData.totalSpent,
      lifetimeTotal,
      monthlyTotal,
      tier,
      history: loyaltyData.history || []
    });
  } catch (error) {
    console.error('Error fetching loyalty info:', error);
    return c.json({ error: 'Failed to fetch loyalty info' }, 500);
  }
});

app.get('/make-server-a75b5353/loyalty/info', requireAuth, async (c) => {
  try {
    const user = c.get('user');
    const userLoyaltyKey = `user_loyalty:${user.id}`;
    let loyaltyData = await kv.get(userLoyaltyKey);
    
    if (!loyaltyData) {
      loyaltyData = {
        userId: user.id,
        points: 0,
        totalEarned: 0,
        totalSpent: 0,
        history: []
      };
    }
    
    // Calculate lifetime total for new progressive system
    const lifetimeTotal = await getUserLifetimeTotal(user.id);
    
    // Determine tier based on lifetime total
    let tier: 'basic' | 'silver' | 'gold' | 'platinum' = 'basic';
    if (lifetimeTotal >= 200000) {
      tier = 'platinum'; // 10%
    } else if (lifetimeTotal >= 100000) {
      tier = 'gold'; // 7%
    } else if (lifetimeTotal >= 50000) {
      tier = 'silver'; // 5%
    } else {
      tier = 'basic'; // 3%
    }
    
    // Also calculate monthly total for backward compatibility
    const monthlyTotal = await getUserMonthlyTotal(user.id);
    
    return c.json({
      points: loyaltyData.points,
      totalEarned: loyaltyData.totalEarned,
      totalSpent: loyaltyData.totalSpent,
      lifetimeTotal,
      monthlyTotal,
      tier,
      history: loyaltyData.history || []
    });
  } catch (error) {
    console.error('Error fetching loyalty info:', error);
    return c.json({ error: 'Failed to fetch loyalty info' }, 500);
  }
});

// Promo codes - Get all (admin only)
app.get('/make-server-a75b5353/promo-codes', requireAdmin, async (c) => {
  try {
    const promoCodes = await kv.getByPrefix('promo:');
    return c.json({ promoCodes: promoCodes.map(p => p.value) });
  } catch (error) {
    console.error('Error fetching promo codes:', error);
    return c.json({ error: 'Failed to fetch promo codes' }, 500);
  }
});

// Validate promo code
app.get('/make-server-a75b5353/promo-codes/validate', requireAuth, async (c) => {
  try {
    const code = c.req.query('code');
    if (!code) {
      return c.json({ error: 'Promo code required' }, 400);
    }
    
    const promoCode = await kv.get(`promo:${code.toUpperCase()}`);
    
    if (!promoCode) {
      return c.json({ error: 'Invalid promo code' }, 404);
    }
    
    // Check if active
    if (!promoCode.active) {
      return c.json({ error: 'Promo code is not active' }, 400);
    }
    
    // Check expiry
    if (promoCode.expiryDate && new Date(promoCode.expiryDate) < new Date()) {
      return c.json({ error: 'Promo code has expired' }, 400);
    }
    
    // Check usage limit
    if (promoCode.usageLimit && promoCode.timesUsed >= promoCode.usageLimit) {
      return c.json({ error: 'Promo code usage limit reached' }, 400);
    }
    
    return c.json(promoCode);
  } catch (error) {
    console.error('Error validating promo code:', error);
    return c.json({ error: 'Failed to validate promo code' }, 500);
  }
});

// Create promo code (admin only)
app.post('/make-server-a75b5353/promo-codes', requireAdmin, async (c) => {
  try {
    const promoData = await c.req.json();
    const code = promoData.code.toUpperCase();
    
    const promoCode = {
      code,
      discount_type: promoData.discount_type,
      discount_value: promoData.discount_value,
      expiryDate: promoData.expiryDate || null,
      usageLimit: promoData.usageLimit || null,
      timesUsed: 0,
      active: promoData.active !== undefined ? promoData.active : true,
      createdAt: new Date().toISOString()
    };
    
    await kv.set(`promo:${code}`, promoCode);
    return c.json({ success: true, promoCode });
  } catch (error) {
    console.error('Error creating promo code:', error);
    return c.json({ error: 'Failed to create promo code' }, 500);
  }
});

// Update promo code (admin only)
app.put('/make-server-a75b5353/promo-codes/:code', requireAdmin, async (c) => {
  try {
    const code = c.req.param('code').toUpperCase();
    const promoData = await c.req.json();
    
    const existingPromo = await kv.get(`promo:${code}`);
    if (!existingPromo) {
      return c.json({ error: 'Promo code not found' }, 404);
    }
    
    const promoCode = {
      ...existingPromo,
      ...promoData,
      code,
    };
    
    await kv.set(`promo:${code}`, promoCode);
    return c.json({ success: true, promoCode });
  } catch (error) {
    console.error('Error updating promo code:', error);
    return c.json({ error: 'Failed to update promo code' }, 500);
  }
});

// Delete promo code (admin only)
app.delete('/make-server-a75b5353/promo-codes/:code', requireAdmin, async (c) => {
  try {
    const code = c.req.param('code').toUpperCase();
    await kv.del(`promo:${code}`);
    return c.json({ success: true });
  } catch (error) {
    console.error('Error deleting promo code:', error);
    return c.json({ error: 'Failed to delete promo code' }, 500);
  }
});

// Get all users (admin only)
app.get('/make-server-a75b5353/admin/users', requireAdmin, async (c) => {
  try {
    const supabase = getSupabaseAdmin();
    
    // Get users from profiles table
    const { data: profiles, error: profilesError } = await supabase
      .from('profiles')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (profilesError) {
      console.error('‚ùå Error fetching profiles from DB:', profilesError);
      return c.json({ error: 'Failed to fetch users', details: profilesError.message }, 500);
    }
    
    if (!profiles || profiles.length === 0) {
      console.log('‚ö†Ô∏è No profiles found in database');
      return c.json({ users: [] });
    }
    
    console.log(`‚úÖ Found ${profiles.length} profiles`);
    
    const formattedUsers = profiles.map(profile => ({
      id: profile.id,
      email: profile.email,
      name: profile.name,
      isAdmin: profile.is_admin || false,
      isWholesaler: profile.is_wholesaler || false,
      createdAt: profile.created_at,
      loyaltyPoints: profile.loyalty_points || 0,
      loyaltyTier: profile.loyalty_tier || 'basic',
      monthlyTotal: profile.monthly_total || 0,
    }));
    
    return c.json({ users: formattedUsers });
  } catch (error) {
    console.error('‚ùå Exception fetching users:', error);
    return c.json({ error: 'Failed to fetch users', details: String(error) }, 500);
  }
});

// Update user role (admin only)
app.put('/make-server-a75b5353/admin/users/:id/role', requireAdmin, async (c) => {
  try {
    const userId = c.req.param('id');
    const { isWholesaler, isAdmin } = await c.req.json();
    
    const supabase = getSupabaseAdmin();
    
    console.log(`üìù Updating user ${userId} role: isAdmin=${isAdmin}, isWholesaler=${isWholesaler}`);
    
    // Update in profiles table
    const { error } = await supabase
      .from('profiles')
      .update({ 
        is_admin: isAdmin,
        is_wholesaler: isWholesaler 
      })
      .eq('id', userId);
    
    if (error) {
      console.error('‚ùå Error updating user role:', error);
      return c.json({ error: 'Failed to update user role', details: error.message }, 500);
    }
    
    console.log(`‚úÖ User ${userId} role updated successfully`);
    return c.json({ success: true });
  } catch (error) {
    console.error('‚ùå Exception updating user role:', error);
    return c.json({ error: 'Failed to update user role', details: String(error) }, 500);
  }
});

// Update user wholesaler status (admin only) - legacy endpoint
app.put('/make-server-a75b5353/admin/users/:id/wholesaler', requireAdmin, async (c) => {
  try {
    const userId = c.req.param('id');
    const { isWholesaler } = await c.req.json();
    
    const supabase = getSupabaseAdmin();
    
    // Update in profiles table
    const { error } = await supabase
      .from('profiles')
      .update({ is_wholesaler: isWholesaler })
      .eq('id', userId);
    
    if (error) {
      console.error('Error updating user:', error);
      return c.json({ error: 'Failed to update user' }, 500);
    }
    
    return c.json({ success: true });
  } catch (error) {
    console.error('Error updating user wholesaler status:', error);
    return c.json({ error: 'Failed to update wholesaler status' }, 500);
  }
});

// ============================================
// User Profile Settings Endpoints
// ============================================

// Get user settings
app.get('/make-server-a75b5353/user/settings', async (c) => {
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    if (!accessToken) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const supabase = getSupabaseAdmin();
    const { data: { user }, error: authError } = await supabase.auth.getUser(accessToken);
    
    if (authError || !user) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const { data: profile, error } = await supabase
      .from('profiles')
      .select('subscribed_to_newsletter')
      .eq('id', user.id)
      .single();

    if (error) {
      console.error('Error fetching user settings:', error);
      return c.json({ subscribed: false });
    }

    return c.json({ subscribed: profile?.subscribed_to_newsletter || false });
  } catch (error) {
    console.error('Error in user settings:', error);
    return c.json({ error: 'Failed to fetch settings' }, 500);
  }
});

// Update user email
app.post('/make-server-a75b5353/user/update-email', async (c) => {
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    if (!accessToken) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const supabase = getSupabaseAdmin();
    const { data: { user }, error: authError } = await supabase.auth.getUser(accessToken);
    
    if (authError || !user) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const { newEmail } = await c.req.json();

    if (!newEmail || !newEmail.includes('@')) {
      return c.json({ error: 'Invalid email' }, 400);
    }

    // Update email in auth.users
    const { error: updateError } = await supabase.auth.admin.updateUserById(
      user.id,
      { email: newEmail }
    );

    if (updateError) {
      console.error('Error updating email:', updateError);
      return c.json({ error: 'Failed to update email', message: updateError.message }, 500);
    }

    // Update email in profiles table
    await supabase
      .from('profiles')
      .update({ email: newEmail })
      .eq('id', user.id);

    console.log(`‚úÖ Email updated for user ${user.id}: ${newEmail}`);
    return c.json({ success: true });
  } catch (error) {
    console.error('Error updating user email:', error);
    return c.json({ error: 'Failed to update email' }, 500);
  }
});

// Toggle newsletter subscription
app.post('/make-server-a75b5353/user/toggle-subscription', async (c) => {
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    if (!accessToken) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const supabase = getSupabaseAdmin();
    const { data: { user }, error: authError } = await supabase.auth.getUser(accessToken);
    
    if (authError || !user) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const { subscribed } = await c.req.json();

    const { error } = await supabase
      .from('profiles')
      .update({ subscribed_to_newsletter: subscribed })
      .eq('id', user.id);

    if (error) {
      console.error('Error updating subscription:', error);
      return c.json({ error: 'Failed to update subscription' }, 500);
    }

    console.log(`‚úÖ Subscription updated for user ${user.id}: ${subscribed}`);
    return c.json({ success: true });
  } catch (error) {
    console.error('Error toggling subscription:', error);
    return c.json({ error: 'Failed to toggle subscription' }, 500);
  }
});

// Get newsletter subscribers count (admin only)
app.get('/make-server-a75b5353/newsletter/subscribers/count', requireAdmin, async (c) => {
  try {
    const supabase = getSupabaseAdmin();
    
    const { count, error } = await supabase
      .from('profiles')
      .select('*', { count: 'exact', head: true })
      .eq('subscribed_to_newsletter', true);
    
    if (error) {
      console.error('Error fetching subscribers count:', error);
      return c.json({ error: 'Failed to fetch subscribers count' }, 500);
    }
    
    console.log(`üìä Newsletter subscribers count: ${count}`);
    return c.json({ count: count || 0 });
  } catch (error) {
    console.error('Error in subscribers count:', error);
    return c.json({ error: 'Failed to fetch subscribers count' }, 500);
  }
});

// Send newsletter broadcast (admin only)
app.post('/make-server-a75b5353/newsletter/broadcast', requireAdmin, async (c) => {
  try {
    const { subject, htmlContent } = await c.req.json();
    
    if (!subject || !htmlContent) {
      return c.json({ error: 'Subject and HTML content are required' }, 400);
    }
    
    const supabase = getSupabaseAdmin();
    
    // Get all subscribed users with their email and language preference
    const { data: subscribers, error } = await supabase
      .from('profiles')
      .select('id, email, name, language')
      .eq('subscribed_to_newsletter', true);
    
    if (error) {
      console.error('Error fetching subscribers:', error);
      return c.json({ error: 'Failed to fetch subscribers', details: error.message }, 500);
    }
    
    if (!subscribers || subscribers.length === 0) {
      return c.json({ error: 'No subscribers found' }, 404);
    }
    
    console.log(`üìß Starting newsletter broadcast to ${subscribers.length} subscribers`);
    console.log(`‚è±Ô∏è Estimated time: ${Math.ceil(subscribers.length * 0.6)} seconds (0.6s per email)`);
    
    const resendApiKey = Deno.env.get('RESEND_API_KEY');
    if (!resendApiKey) {
      return c.json({ error: 'RESEND_API_KEY not configured' }, 500);
    }
    
    // Import email template function
    const { generateBroadcastEmailHTML } = await import('./email-templates.tsx');
    
    let sentCount = 0;
    let failedCount = 0;
    
    // Send emails with delay to avoid rate limiting
    for (let i = 0; i < subscribers.length; i++) {
      const subscriber = subscribers[i];
      try {
        const userLanguage = (subscriber.language || 'ru') as 'ru' | 'en' | 'zh' | 'vi';
        const unsubscribeUrl = 'https://asia-pharm.com/profile';
        
        // Generate full email with header and footer
        const fullHtml = generateBroadcastEmailHTML(
          subject,
          htmlContent,
          userLanguage,
          unsubscribeUrl
        );
        
        // Send email via Resend
        const response = await fetch('https://api.resend.com/emails', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${resendApiKey}`
          },
          body: JSON.stringify({
            from: 'Asia Pharm <info@asia-pharm.com>',
            to: [subscriber.email],
            subject: subject,
            html: fullHtml
          })
        });
        
        if (response.ok) {
          sentCount++;
          console.log(`‚úÖ [${i + 1}/${subscribers.length}] Email sent to ${subscriber.email}`);
        } else {
          failedCount++;
          const errorData = await response.text();
          console.error(`‚ùå [${i + 1}/${subscribers.length}] Failed to send to ${subscriber.email}:`, errorData);
          
          // If rate limited, wait longer before next attempt
          if (response.status === 429) {
            console.log('‚è≥ Rate limit hit, waiting 2 seconds before continuing...');
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        }
        
        // Delay to respect Resend rate limit (2 requests/second = 500ms minimum)
        // Using 600ms to be safe
        await new Promise(resolve => setTimeout(resolve, 600));
        
      } catch (emailError) {
        failedCount++;
        console.error(`‚ùå [${i + 1}/${subscribers.length}] Error sending to ${subscriber.email}:`, emailError);
      }
    }
    
    console.log(`üìä Broadcast complete: ${sentCount} sent, ${failedCount} failed`);
    
    return c.json({
      success: true,
      sent: sentCount,
      failed: failedCount,
      total: subscribers.length
    });
    
  } catch (error) {
    console.error('Error in newsletter broadcast:', error);
    return c.json({ error: 'Failed to send broadcast', details: String(error) }, 500);
  }
});

// Delete user account
app.delete('/make-server-a75b5353/user/delete-account', async (c) => {
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1];
    if (!accessToken) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const supabase = getSupabaseAdmin();
    const { data: { user }, error: authError } = await supabase.auth.getUser(accessToken);
    
    if (authError || !user) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    // Delete user from auth.users (this will cascade delete from profiles due to FK constraint)
    const { error: deleteError } = await supabase.auth.admin.deleteUser(user.id);

    if (deleteError) {
      console.error('Error deleting user:', deleteError);
      return c.json({ error: 'Failed to delete account' }, 500);
    }

    console.log(`‚úÖ Account deleted for user ${user.id}`);
    return c.json({ success: true });
  } catch (error) {
    console.error('Error deleting account:', error);
    return c.json({ error: 'Failed to delete account' }, 500);
  }
});

// Initialize with demo data
app.post('/make-server-a75b5353/init-demo-data', requireAdmin, async (c) => {
  try {
    const demoProducts = [
      // –¢–û–í–ê–†–´ –ò–ó –ö–ò–¢–ê–Ø
      {
        id: crypto.randomUUID(),
        name: '–¢–∏–≥—Ä–æ–≤—ã–π –±–∞–ª—å–∑–∞–º',
        name_en: 'Tiger Balm',
        name_zh: 'ËôéÊ†á‰∏áÈáëÊ≤π',
        name_vi: 'D·∫ßu con h·ªï',
        price: 599,
        wholesalePrice: 45,
        weight: 0.05,
        category: 'ointments',
        disease: 'joints',
        store: 'china',
        description: '–¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π –∫–∏—Ç–∞–π—Å–∫–∏–π –±–∞–ª—å–∑–∞–º –¥–ª—è —Å–Ω—è—Ç–∏—è –±–æ–ª–∏ –≤ –º—ã—à—Ü–∞—Ö –∏ —Å—É—Å—Ç–∞–≤–∞—Ö',
        description_en: 'Traditional Chinese balm for muscle and joint pain relief',
        description_zh: '‰º†Áªü‰∏≠ÂõΩËÜèËçØÔºåÁî®‰∫éÁºìËß£ËÇåËÇâÂíåÂÖ≥ËäÇÁñºÁóõ',
        description_vi: 'D·∫ßu truy·ªÅn th·ªëng Trung Qu·ªëc gi·∫£m ƒëau c∆° v√† kh·ªõp',
        composition: '–ú–µ–Ω—Ç–æ–ª, –∫–∞–º—Ñ–æ—Ä–∞, –º–∞—Å–ª–æ –≥–≤–æ–∑–¥–∏–∫–∏',
        composition_en: 'Menthol, camphor, clove oil',
        composition_zh: 'ËñÑËç∑ÈÜá„ÄÅÊ®üËÑë„ÄÅ‰∏ÅÈ¶ôÊ≤π',
        composition_vi: 'B·∫°c h√†, long n√£o, d·∫ßu ƒëinh h∆∞∆°ng',
        usage: '–ù–∞–Ω–æ—Å–∏—Ç—å –Ω–∞ –±–æ–ª—å–Ω—ã–µ —É—á–∞—Å—Ç–∫–∏ 2-3 —Ä–∞–∑–∞ –≤ –¥–µ–Ω—å',
        usage_en: 'Apply to affected areas 2-3 times daily',
        usage_zh: 'ÊØèÂ§©Ê∂ÇÊäπÊÇ£Â§Ñ2-3Ê¨°',
        usage_vi: 'B√¥i v√†o v√πng b·ªã ƒëau 2-3 l·∫ßn m·ªói ng√†y',
        image: 'https://images.unsplash.com/photo-1709813610121-e2a51545e212?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHx0cmFkaXRpb25hbCUyMG1lZGljaW5lJTIwb2ludG1lbnR8ZW58MXx8fHwxNzYwODk0NjE1fDA&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
      {
        id: crypto.randomUUID(),
        name: '–ñ–µ–Ω—å—à–µ–Ω–µ–≤—ã–µ –∫–∞–ø—Å—É–ª—ã',
        name_en: 'Ginseng Capsules',
        name_zh: '‰∫∫ÂèÇËÉ∂Âõä',
        name_vi: 'Vi√™n nang nh√¢n s√¢m',
        price: 1200,
        wholesalePrice: 90,
        weight: 0.08,
        category: 'capsules',
        disease: 'nervous',
        store: 'china',
        description: '–ö–∞–ø—Å—É–ª—ã —Å —ç–∫—Å—Ç—Ä–∞–∫—Ç–æ–º –∫–æ—Ä–Ω—è –∂–µ–Ω—å—à–µ–Ω—è –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è —ç–Ω–µ—Ä–≥–∏–∏ –∏ —É–∫—Ä–µ–ø–ª–µ–Ω–∏—è –∏–º–º—É–Ω–∏—Ç–µ—Ç–∞',
        description_en: 'Ginseng root extract capsules for energy and immunity boost',
        description_zh: '‰∫∫ÂèÇÊ†πÊèêÂèñÁâ©ËÉ∂ÂõäÔºåÂ¢ûÂº∫ËÉΩÈáèÂíåÂÖçÁñ´Âäõ',
        description_vi: 'Vi√™n nang chi·∫øt xu·∫•t r·ªÖ nh√¢n s√¢m tƒÉng c∆∞·ªùng nƒÉng l∆∞·ª£ng v√† mi·ªÖn d·ªãch',
        composition: '–≠–∫—Å—Ç—Ä–∞–∫—Ç –∫–æ—Ä–Ω—è –∂–µ–Ω—å—à–µ–Ω—è, –≤–∏—Ç–∞–º–∏–Ω –°',
        composition_en: 'Ginseng root extract, vitamin C',
        composition_zh: '‰∫∫ÂèÇÊ†πÊèêÂèñÁâ©„ÄÅÁª¥ÁîüÁ¥†C',
        composition_vi: 'Chi·∫øt xu·∫•t r·ªÖ nh√¢n s√¢m, vitamin C',
        usage: '–ü—Ä–∏–Ω–∏–º–∞—Ç—å –ø–æ 1-2 –∫–∞–ø—Å—É–ª—ã —É—Ç—Ä–æ–º',
        usage_en: 'Take 1-2 capsules in the morning',
        usage_zh: 'ÊØèÂ§©Êó©‰∏äÊúçÁî®1-2Á≤í',
        usage_vi: 'U·ªëng 1-2 vi√™n v√†o bu·ªïi s√°ng',
        image: 'https://images.unsplash.com/photo-1584308666744-24d5c474f2ae?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxoZXJiYWwlMjBjYXBzdWxlc3xlbnwxfHx8fDE3NjA4OTQ2MTZ8MA&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
      {
        id: crypto.randomUUID(),
        name: '–ö–∏—Ç–∞–π—Å–∫–∏–π –ª–µ—á–µ–±–Ω—ã–π –ø–ª–∞—Å—Ç—ã—Ä—å –¥–ª—è —Å—É—Å—Ç–∞–≤–æ–≤',
        name_en: 'Chinese Joint Pain Relief Patch',
        name_zh: '‰∏≠ÂõΩÂÖ≥ËäÇÊ≠¢ÁóõË¥¥',
        name_vi: 'Mi·∫øng d√°n gi·∫£m ƒëau kh·ªõp Trung Qu·ªëc',
        price: 850,
        wholesalePrice: 65,
        weight: 0.03,
        category: 'patches',
        disease: 'joints',
        store: 'china',
        description: '–°–æ–≥—Ä–µ–≤–∞—é—â–∏–π –ø–ª–∞—Å—Ç—ã—Ä—å —Å —Ç—Ä–∞–≤—è–Ω—ã–º–∏ —ç–∫—Å—Ç—Ä–∞–∫—Ç–∞–º–∏ –¥–ª—è –æ–±–ª–µ–≥—á–µ–Ω–∏—è –±–æ–ª–∏ –≤ —Å—É—Å—Ç–∞–≤–∞—Ö',
        description_en: 'Warming patch with herbal extracts for joint pain relief',
        description_zh: 'Âê´ËçâËçØÊèêÂèñÁâ©ÁöÑÔøΩÔøΩÁÉ≠Ë¥¥ËÜèÔºåÁºìËß£ÂÖ≥ËäÇÁñºÁóõ',
        description_vi: 'Mi·∫øng d√°n ·∫•m v·ªõi chi·∫øt xu·∫•t th·∫£o d∆∞·ª£c gi·∫£m ƒëau kh·ªõp',
        composition: '–ö–∞–º—Ñ–æ—Ä–∞, –º–µ–Ω—Ç–æ–ª, —ç–∫—Å—Ç—Ä–∞–∫—Ç –ø–µ—Ä—Ü–∞',
        composition_en: 'Camphor, menthol, pepper extract',
        composition_zh: 'Ê®üËÑë„ÄÅËñÑËç∑ÈÜá„ÄÅËæ£Ê§íÊèêÂèñÁâ©',
        composition_vi: 'Long n√£o, b·∫°c h√†, chi·∫øt xu·∫•t ·ªõt',
        usage: '–ù–∞–∫–ª–µ–∏—Ç—å –Ω–∞ –±–æ–ª–µ–≤—É—é –∑–æ–Ω—É, –Ω–æ—Å–∏—Ç—å 8-12 —á–∞—Å–æ–≤',
        usage_en: 'Apply to pain area, wear for 8-12 hours',
        usage_zh: 'Ë¥¥‰∫éÁñºÁóõÂå∫ÂüüÔºå‰Ω©Êà¥8-12Â∞èÊó∂',
        usage_vi: 'D√°n v√†o v√πng ƒëau, ƒëeo trong 8-12 gi·ªù',
        image: 'https://images.unsplash.com/photo-1631549916768-4119b2e5f926?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxjaGluZXNlJTIwbWVkaWNpbmUlMjBwYXRjaHxlbnwxfHx8fDE3NjA4OTQ2MTd8MA&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
      {
        id: crypto.randomUUID(),
        name: '–ö–∏—Ç–∞–π—Å–∫–∏–µ –∫–∞–ø–ª–∏ –¥–ª—è –≥–ª–∞–∑',
        name_en: 'Chinese Eye Drops',
        name_zh: '‰∏≠ÂõΩÁúºËçØÊ∞¥',
        name_vi: 'Thu·ªëc nh·ªè m·∫Øt Trung Qu·ªëc',
        price: 550,
        wholesalePrice: 42,
        weight: 0.03,
        category: 'drops',
        disease: 'eyes',
        store: 'china',
        description: '–ì–ª–∞–∑–Ω—ã–µ –∫–∞–ø–ª–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ö—Ä–∏–∑–∞–Ω—Ç–µ–º—ã –¥–ª—è —Å–Ω—è—Ç–∏—è —É—Å—Ç–∞–ª–æ—Å—Ç–∏ –∏ –ø–æ–∫—Ä–∞—Å–Ω–µ–Ω–∏—è –≥–ª–∞–∑',
        description_en: 'Chrysanthemum-based eye drops for relieving eye fatigue and redness',
        description_zh: 'ËèäËä±ÁúºËçØÊ∞¥ÔºåÁºìËß£ÁúºÁùõÁñ≤Âä≥ÂíåÁ∫¢Ë°Ä‰∏ù',
        description_vi: 'Thu·ªëc nh·ªè m·∫Øt t·ª´ c√∫c hoa gi·∫£m m·ªèi m·∫Øt v√† ƒë·ªè m·∫Øt',
        composition: '–≠–∫—Å—Ç—Ä–∞–∫—Ç —Ö—Ä–∏–∑–∞–Ω—Ç–µ–º—ã, –≥–∏–∞–ª—É—Ä–æ–Ω–æ–≤–∞—è –∫–∏—Å–ª–æ—Ç–∞',
        composition_en: 'Chrysanthemum extract, hyaluronic acid',
        composition_zh: 'ËèäËä±ÊèêÂèñÁâ©„ÄÅÈÄèÊòéË¥®ÈÖ∏',
        composition_vi: 'Chi·∫øt xu·∫•t hoa c√∫c, axit hyaluronic',
        usage: '–ó–∞–∫–∞–ø—ã–≤–∞—Ç—å –ø–æ 1-2 –∫–∞–ø–ª–∏ –≤ –∫–∞–∂–¥—ã–π –≥–ª–∞–∑ 3-4 —Ä–∞–∑–∞ –≤ –¥–µ–Ω—å',
        usage_en: 'Instill 1-2 drops in each eye 3-4 times daily',
        usage_zh: 'ÊØèÂ§©Êª¥1-2Êª¥‰∫éÊØèÂè™ÁúºÁùõÔºåÊØèÂ§©3-4Ê¨°',
        usage_vi: 'Nh·ªè 1-2 gi·ªçt v√†o m·ªói m·∫Øt, 3-4 l·∫ßn m·ªói ng√†y',
        image: 'https://images.unsplash.com/photo-1587854692152-cbe660dbde88?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxleWUlMjBkcm9wc3xlbnwxfHx8fDE3NjA4OTQ2MTl8MA&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
      
      // –¢–û–í–ê–†–´ –ò–ó –¢–ê–ò–õ–ê–ù–î–ê
      {
        id: crypto.randomUUID(),
        name: '–¢—Ä–∞–≤—è–Ω–æ–π —á–∞–π –¥–ª—è –ø–∏—â–µ–≤–∞—Ä–µ–Ω–∏—è',
        name_en: 'Digestive Herbal Tea',
        name_zh: 'Ê∂àÂåñËçâËçØËå∂',
        name_vi: 'Tr√† th·∫£o d∆∞·ª£c ti√™u h√≥a',
        price: 450,
        wholesalePrice: 35,
        weight: 0.1,
        category: 'teas',
        disease: 'digestive',
        store: 'thailand',
        description: '–ù–∞—Ç—É—Ä–∞–ª—å–Ω—ã–π —Ç—Ä–∞–≤—è–Ω–æ–π —á–∞–π –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –ø–∏—â–µ–≤–∞—Ä–µ–Ω–∏—è',
        description_en: 'Natural herbal tea for digestive health',
        description_zh: 'Â§©ÁÑ∂ËçâËçØËå∂ÔºåÊîπÂñÑÊ∂àÂåñ',
        description_vi: 'Tr√† th·∫£o d∆∞·ª£c t·ª± nhi√™n t·ªët cho ti√™u h√≥a',
        composition: '–ò–º–±–∏—Ä—å, –º—è—Ç–∞, —Ñ–µ–Ω—Ö–µ–ª—å',
        composition_en: 'Ginger, mint, fennel',
        composition_zh: 'ÁîüÂßú„ÄÅËñÑËç∑„ÄÅËå¥È¶ô',
        composition_vi: 'G·ª´ng, b·∫°c h√†, th√¨ l√†',
        usage: '–ó–∞–≤–∞—Ä–∏–≤–∞—Ç—å 1 –ø–∞–∫–µ—Ç–∏–∫ –Ω–∞ 200–º–ª –∫–∏–ø—è—Ç–∫–∞, –ø–∏—Ç—å –ø–æ—Å–ª–µ –µ–¥—ã',
        usage_en: 'Steep 1 bag in 200ml hot water, drink after meals',
        usage_zh: 'Áî®200ÊØ´ÂçáÂºÄÊ∞¥ÂÜ≤Ê≥°1Ë¢ãÔºåÈ•≠ÂêéÈ•ÆÁî®',
        usage_vi: 'Pha 1 t√∫i v·ªõi 200ml n∆∞·ªõc n√≥ng, u·ªëng sau b·ªØa ƒÉn',
        image: 'https://images.unsplash.com/photo-1504382103100-db7e92322d39?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxoZXJiYWwlMjB0ZWF8ZW58MXx8fHwxNzYwODk0NjE2fDA&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
      {
        id: crypto.randomUUID(),
        name: '–¢–∞–π—Å–∫–∏ÔøΩÔøΩ –∑–µ–ª–µ–Ω—ã–π –±–∞–ª—å–∑–∞–º',
        name_en: 'Thai Green Balm',
        name_zh: 'Ê≥∞ÂõΩÁªøËâ≤È¶ôËÜè',
        name_vi: 'D·∫ßu xanh Th√°i Lan',
        price: 680,
        wholesalePrice: 52,
        weight: 0.05,
        category: 'ointments',
        disease: 'headache',
        store: 'thailand',
        description: '–û—Ö–ª–∞–∂–¥–∞—é—â–∏–π –±–∞–ª—å–∑–∞–º –æ—Ç –≥–æ–ª–æ–≤–Ω–æ–π –±–æ–ª–∏ –∏ –Ω–∞—Å–º–æ—Ä–∫–∞',
        description_en: 'Cooling balm for headaches and nasal congestion',
        description_zh: 'Ê∏ÖÂáâÈ¶ôËÜèÔºåÁºìËß£Â§¥ÁóõÂíåÈºªÂ°û',
        description_vi: 'D·∫ßu m√°t gi·∫£m ƒëau ƒë·∫ßu v√† ngh·∫πt m≈©i',
        composition: '–≠–≤–∫–∞–ª–∏–ø—Ç, –º—è—Ç–∞, –º–µ–Ω—Ç–æ–ª, –∫–∞–º—Ñ–æ—Ä–∞',
        composition_en: 'Eucalyptus, mint, menthol, camphor',
        composition_zh: 'Ê°âÊ†ë„ÄÅËñÑËç∑„ÄÅËñÑËç∑ÈÜá„ÄÅÊ®üËÑë',
        composition_vi: 'B·∫°ch ƒë√†n, b·∫°c h√†, menthol, long n√£o',
        usage: '–í—Ç–∏—Ä–∞—Ç—å –≤ –≤–∏—Å–∫–∏ –∏ –ø–µ—Ä–µ–Ω–æ—Å–∏—Ü—É –ø—Ä–∏ –≥–æ–ª–æ–≤–Ω–æ–π –±–æ–ª–∏',
        usage_en: 'Rub on temples and bridge of nose for headaches',
        usage_zh: 'ÔøΩÔøΩÁóõÊó∂Êì¶Âú®Â§™Èò≥Á©¥ÂíåÈºªÊ¢Å‰∏ä',
        usage_vi: 'Xoa l√™n th√°i d∆∞∆°ng v√† s·ªëng m≈©i khi ƒëau ƒë·∫ßu',
        image: 'https://images.unsplash.com/photo-1608571423902-eed4a5ad8108?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHx0aGFpJTIwYmFsbXxlbnwxfHx8fDE3NjA4OTQ2MTd8MA&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
      {
        id: crypto.randomUUID(),
        name: 'ÔøΩÔøΩ–∞–π—Å–∫–æ–µ –º–∞—Å–ª–æ –¥–ª—è –º–∞—Å—Å–∞–∂–∞',
        name_en: 'Thai Massage Oil',
        name_zh: 'Ê≥∞ÂºèÊåâÊë©Ê≤π',
        name_vi: 'D·∫ßu m√°t-xa Th√°i',
        price: 950,
        wholesalePrice: 72,
        weight: 0.15,
        category: 'oils',
        disease: 'joints',
        store: 'thailand',
        description: '–ù–∞—Ç—É—Ä–∞–ª—å–Ω–æ–µ –º–∞—Å–ª–æ —Å –ª–µ–º–æ–Ω–≥—Ä–∞—Å—Å–æ–º –¥–ª—è —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ç–∞–π—Å–∫–æ–≥–æ –º–∞—Å—Å–∞–∂–∞',
        description_en: 'Natural oil with lemongrass for traditional Thai massage',
        description_zh: 'Âê´Êü†Ê™¨ËçâÁöÑÂ§©ÁÑ∂Ê≤πÔºåÁî®‰∫é‰º†ÁªüÊ≥∞ÂºèÊåâÊë©',
        description_vi: 'D·∫ßu t·ª± nhi√™n v·ªõi s·∫£ cho m√°t-xa Th√°i truy·ªÅn th·ªëng',
        composition: '–ú–∞—Å–ª–æ –∫–æ–∫–æ—Å–∞, –ª–µ–º–æ–Ω–≥—Ä–∞—Å—Å, –∏–º–±–∏—Ä—å, –∫—É—Ä–∫—É–º–∞',
        composition_en: 'Coconut oil, lemongrass, ginger, turmeric',
        composition_zh: 'Ê§∞Â≠êÊ≤π„ÄÅÊü†Ê™¨Ëçâ„ÄÅÁîüÂßú„ÄÅÂßúÈªÑ',
        composition_vi: 'D·∫ßu d·ª´a, s·∫£, g·ª´ng, ngh·ªá',
        usage: '–ù–∞–Ω–æ—Å–∏—Ç—å –º–∞—Å—Å–∞–∂–Ω—ã–º–∏ –¥–≤–∏–∂–µ–Ω–∏—è–º–∏ –Ω–∞ –∫–æ–∂—É',
        usage_en: 'Apply with massage movements to skin',
        usage_zh: 'ÊåâÊë©Ê∂ÇÊäπ‰∫éÁöÆËÇ§',
        usage_vi: 'Thoa v√† xoa b√≥p l√™n da',
        image: 'https://images.unsplash.com/photo-1600334129128-685c5582fd35?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxtYXNzYWdlJTIwb2lsfGVufDF8fHx8MTc2MDg5NDYxN3ww&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
      {
        id: crypto.randomUUID(),
        name: '–¢–∞–π—Å–∫–∏–µ –∫–æ–º–ø—Ä–µ—Å—Å–∏–æ–Ω–Ω—ã–µ —Ç—Ä–∞–≤—è–Ω—ã–µ –º–µ—à–æ—á–∫–∏',
        name_en: 'Thai Herbal Compress Balls',
        name_zh: 'Ê≥∞ÂºèËçâËçØÂéãÁº©ÁêÉ',
        name_vi: 'T√∫i th·∫£o d∆∞·ª£c n√©n Th√°i',
        price: 890,
        wholesalePrice: 68,
        weight: 0.25,
        category: 'herbs',
        disease: 'joints',
        store: 'thailand',
        description: '–ì–æ—Ä—è—á–∏–µ —Ç—Ä–∞–≤—è–Ω—ã–µ –∫–æ–º–ø—Ä–µ—Å—Å—ã –¥–ª—è —Ç–∞–π—Å–∫–æ–≥–æ –º–∞—Å—Å–∞–∂–∞ –∏ —Å–Ω—è—Ç–∏—è –º—ã—à–µ—á–Ω–æ–≥–æ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è',
        description_en: 'Hot herbal compresses for Thai massage and muscle tension relief',
        description_zh: 'ÁÉ≠ËçâËçØÂéãÁº©ÂåÖÔºåÁî®‰∫éÊ≥∞ÂºèÊåâÊë©ÂíåÁºìËß£ËÇåËÇâÁ¥ßÂº†',
        description_vi: 'T√∫i n√©n th·∫£o d∆∞·ª£c n√≥ng cho m√°t-xa Th√°i v√† gi·∫£m cƒÉng c∆°',
        composition: '–õ–µ–º–æ–Ω–≥—Ä–∞—Å—Å, –∏–º–±–∏—Ä—å, –∫—É—Ä–∫—É–º–∞, –∫–∞—Ñ–∏—Ä-–ª–∞–π–º',
        composition_en: 'Lemongrass, ginger, turmeric, kaffir lime',
        composition_zh: 'Êü†Ê™¨Ëçâ„ÄÅÁîüÂßú„ÄÅÂßúÈªÑ„ÄÅÂç°Ëè≤Â∞îÈÖ∏Ê©ô',
        composition_vi: 'S·∫£, g·ª´ng, ngh·ªá, chanh kaffir',
        usage: '–†–∞—Å–ø–∞—Ä–∏—Ç—å –≤ –≥–æ—Ä—è—á–µ–π –≤–æ–¥–µ 5-10 –º–∏–Ω—É—Ç, –ø—Ä–∏–∫–ª–∞–¥—ã–≤–∞—Ç—å –∫ –±–æ–ª—å–Ω—ã–º –º–µ—Å—Ç–∞–º',
        usage_en: 'Steam in hot water for 5-10 minutes, apply to sore areas',
        usage_zh: 'Âú®ÁÉ≠Ê∞¥‰∏≠Ëí∏5-10ÂàÜÈíüÔºåÊï∑Âú®ÁñºÁóõÈÉ®‰Ωç',
        usage_vi: 'H·∫•p trong n∆∞·ªõc n√≥ng 5-10 ph√∫t, ƒë·∫Øp l√™n v√πng ƒëau',
        image: 'https://images.unsplash.com/photo-1544161515-4ab6ce6db874?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHx0aGFpJTIwaGVyYnN8ZW58MXx8fHwxNzYwODk0NjE5fDA&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
      
      // –¢–û–í–ê–†–´ –ò–ó –í–¨–ï–¢ÔøΩÔøΩ–ê–ú–ê
      {
        id: crypto.randomUUID(),
        name: '–õ–µ—á–µ–±–Ω—ã–π –ø–ª–∞—Å—Ç—ã—Ä—å',
        name_en: 'Healing Patch',
        name_zh: 'Ê≤ªÁñóË¥¥ËÜè',
        name_vi: 'Mi·∫øng d√°n ch·ªØa b·ªánh',
        price: 750,
        wholesalePrice: 57,
        weight: 0.02,
        category: 'patches',
        disease: 'skin',
        store: 'vietnam',
        description: '–ü–ª–∞—Å—Ç—ã—Ä—å —Å —Ç—Ä–∞–≤—è–Ω—ã–º–∏ —ç–∫—Å—Ç—Ä–∞–∫—Ç–∞–º–∏ –¥–ª—è –∑–∞–∂–∏–≤–ª–µ–Ω–∏—è –∫–æ–∂–∏',
        description_en: 'Herbal extract patch for skin healing',
        description_zh: 'ËçâËçØÊèêÂèñÁâ©Ë¥¥ËÜèÔºå‰øÉËøõÁöÆËÇ§ÊÑàÂêà',
        description_vi: 'Mi·∫øng d√°n chi·∫øt xu·∫•t th·∫£o d∆∞·ª£c ch·ªØa l√†nh da',
        composition: '–≠–∫—Å—Ç—Ä–∞–∫—Ç –∞–ª–æ—ç, —Ü–µ–Ω—Ç–µ–ª–ª–∞ –∞–∑–∏–∞—Ç—Å–∫–∞—è',
        composition_en: 'Aloe extract, centella asiatica',
        composition_zh: 'Ëä¶ËçüÊèêÂèñÁâ©„ÄÅÁßØÈõ™Ëçâ',
        composition_vi: 'Chi·∫øt xu·∫•t l√¥ h·ªôi, rau m√°',
        usage: '–ù–∞–∫–ª–µ–∏—Ç—å –Ω–∞ —á–∏—Å—Ç—É—é —Å—É—Ö—É—é –∫–æ–∂—É, –º–µ–Ω—è—Ç—å –∫–∞–∂–¥—ã–µ 12 —á–∞—Å–æ–≤',
        usage_en: 'Apply to clean dry skin, change every 12 hours',
        usage_zh: 'Ë¥¥‰∫éÊ∏ÖÊ¥ÅÂπ≤Áá•ÁöÑÁöÆËÇ§‰∏äÔºåÊØè12Â∞èÊó∂Êõ¥Êç¢‰∏ÄÊ¨°',
        usage_vi: 'D√°n l√™n da s·∫°ch kh√¥, thay sau m·ªói 12 gi·ªù',
        image: 'https://images.unsplash.com/photo-1609840534277-88833ef3ddeb?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxtZWRpY2FsJTIwcGF0Y2h8ZW58MXx8fHwxNzYwODk0NjE2fDA&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
      {
        id: crypto.randomUUID(),
        name: '–í—å–µ—Ç–Ω–∞–º—Å–∫–∏–π –∑–≤–µ–∑–¥–æ—á–Ω—ã–π –±–∞–ª—å–∑–∞–º',
        name_en: 'Vietnamese Star Balm',
        name_zh: 'Ë∂äÂçóÊòüÂè∑ËÜè',
        name_vi: 'Cao sao v√†ng Vi·ªát Nam',
        price: 320,
        wholesalePrice: 24,
        weight: 0.04,
        category: 'ointments',
        disease: 'cold',
        store: 'vietnam',
        description: '–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –±–∞–ª—å–∑–∞–º –ø—Ä–∏ –ø—Ä–æ—Å—Ç—É–¥–µ, –≥–æ–ª–æ–≤–Ω–æ–π –±–æ–ª–∏, —É–∫—É—Å–∞—Ö –Ω–∞—Å–µ–∫–æ–º—ã—Ö',
        description_en: 'Universal balm for colds, headaches, insect bites',
        description_zh: '‰∏áËÉΩËÜèËçØÔºåÁî®‰∫éÊÑüÂÜí„ÄÅÂ§¥Áóõ„ÄÅËô´Âí¨',
        description_vi: 'Cao ƒëa nƒÉng cho c·∫£m l·∫°nh, ƒëau ƒë·∫ßu, c√¥n tr√πng c·∫Øn',
        composition: '–ö–∞–º—Ñ–æ—Ä–∞, –º–µ–Ω—Ç–æ–ª, –º–∞—Å–ª–æ —ç–≤–∫–∞–ª–∏–ø—Ç–∞, –º—è—Ç—ã',
        composition_en: 'Camphor, menthol, eucalyptus oil, peppermint',
        composition_zh: 'Ê®üËÑë„ÄÅËñÑËç∑ÈÜá„ÄÅÊ°âÊ†ëÊ≤π„ÄÅËñÑËç∑',
        composition_vi: 'Long n√£o, menthol, d·∫ßu b·∫°ch ƒë√†n, b·∫°c h√†',
        usage: '–í—Ç–∏—Ä–∞—Ç—å –Ω–µ–±–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –≥—Ä—É–¥—å, —Å–ø–∏–Ω—É, –≤–∏—Å–∫–∏',
        usage_en: 'Rub a small amount on chest, back, temples',
        usage_zh: 'Â∞ÜÂ∞ëÔøΩÔøΩÊì¶Âú®ËÉ∏ÈÉ®„ÄÅËÉåÈÉ®„ÄÅÂ§™Èò≥Á©¥',
        usage_vi: 'Xoa m·ªôt l∆∞·ª£ng nh·ªè l√™n ng·ª±c, l∆∞ng, th√°i d∆∞∆°ng',
        image: 'https://images.unsplash.com/photo-1585435557343-3b092031a831?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHx2aWV0bmFtZXNlJTIwYmFsbXxlbnwxfHx8fDE3NjA4OTQ2MTh8MA&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
      {
        id: crypto.randomUUID(),
        name: '–ö–∞–ø—Å—É–ª—ã –∏–∑ –∑–º–µ–∏–Ω–æ–≥–æ –∂–∏—Ä–∞',
        name_en: 'Snake Fat Capsules',
        name_zh: 'ËõáÊ≤πËÉ∂Âõä',
        name_vi: 'Vi√™n nang m·ª° r·∫Øn',
        price: 1100,
        wholesalePrice: 84,
        weight: 0.06,
        category: 'capsules',
        disease: 'joints',
        store: 'vietnam',
        description: '–ö–∞–ø—Å—É–ª—ã –∏–∑ –∑–º–µ–∏–Ω–æ–≥–æ –∂–∏—Ä–∞ –¥–ª—è –∑–¥–æ—Ä–æ–≤—å—è —Å—É—Å—Ç–∞–≤–æ–≤ –∏ –∫–æ–∂–∏',
        description_en: 'Snake fat capsules for joint and skin health',
        description_zh: 'ËõáÊ≤πËÉ∂ÂõäÔºåÊúâÁõäÂÖ≥ËäÇÂíåÁöÆËÇ§ÂÅ•Â∫∑',
        description_vi: 'Vi√™n nang m·ª° r·∫Øn t·ªët cho kh·ªõp v√† da',
        composition: '–ñ–∏—Ä –∑–º–µ–∏, –≤–∏—Ç–∞–º–∏–Ω –ï',
        composition_en: 'Snake fat, vitamin E',
        composition_zh: 'ËõáËÑÇ„ÄÅÁª¥ÁîüÁ¥†E',
        composition_vi: 'M·ª° r·∫Øn, vitamin E',
        usage: '–ü—Ä–∏–Ω–∏–º–∞—Ç—å –ø–æ 2 –∫–∞–ø—Å—É–ª—ã 2 —Ä–∞–∑–∞ –≤ –¥ÔøΩÔøΩ–Ω—å',
        usage_en: 'Take 2 capsules twice daily',
        usage_zh: 'ÊØèÂ§©‰∏§Ê¨°ÔºåÊØèÊ¨°2Á≤í',
        usage_vi: 'U·ªëng 2 vi√™n m·ªói ng√†y 2 l·∫ßn',
        image: 'https://images.unsplash.com/photo-1550572017-edd951aa8f72?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxoZXJiYWwlMjBjYXBzdWxlfGVufDF8fHx8MTc2MDg5NDYxOHww&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
      {
        id: crypto.randomUUID(),
        name: '–í—å–µ—Ç–Ω–∞–º—Å–∫–∏–π –º–µ–Ω—Ç–æ–ª–æ–≤—ã–π –∏–Ω–≥–∞–ª—è—Ç–æ—Ä',
        name_en: 'Vietnamese Menthol Inhaler',
        name_zh: 'Ë∂äÂçóËñÑËç∑ÈÜáÂê∏ÂÖ•Âô®',
        name_vi: 'Que h√≠t b·∫°c h√† Vi·ªát Nam',
        price: 280,
        wholesalePrice: 21,
        weight: 0.01,
        category: 'inhalers',
        disease: 'cold',
        store: 'vietnam',
        description: '–ö–∞—Ä–º–∞–Ω–Ω—ã–π –∏–Ω–≥–∞–ª—è—Ç–æ—Ä —Å –º–µ–Ω—Ç–æ–ª–æ–º –∏ —ç–≤–∫–∞–ª–∏–ø—Ç–æ–º –ø—Ä–∏ –∑–∞–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏ –Ω–æ—Å–∞',
        description_en: 'Pocket inhaler with menthol and eucalyptus for nasal congestion',
        description_zh: 'ËñÑËç∑ÂíåÊ°âÊ†ë‰æøÊê∫ÂºèÂê∏ÂÖ•Âô®ÔºåÁî®‰∫éÈºªÂ°û',
        description_vi: 'Que h√≠t b·ªè t√∫i v·ªõi b·∫°c h√† v√† b·∫°ch ƒë√†n cho ngh·∫πt m≈©i',
        composition: '–ú–µ–Ω—Ç–æ–ª, —ç–≤–∫–∞–ª–∏–ø—Ç, –º–∞—Å–ª–æ –º—è—Ç—ã',
        composition_en: 'Menthol, eucalyptus, peppermint oil',
        composition_zh: 'ËñÑËç∑ÈÜá„ÄÅÊ°âÊ†ë„ÄÅËñÑËç∑Ê≤π',
        composition_vi: 'Menthol, b·∫°ch ƒë√†n, d·∫ßu b·∫°c h√†',
        usage: '–í–¥—ã—Ö–∞—Ç—å —á–µ—Ä–µ–∑ –Ω–æ—Å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏',
        usage_en: 'Inhale through nose as needed',
        usage_zh: 'ÈúÄË¶ÅÊó∂ÈÄöËøáÈºªÂ≠êÂê∏ÂÖ•',
        usage_vi: 'H√≠t qua m≈©i khi c·∫ßn thi·∫øt',
        image: 'https://images.unsplash.com/photo-1584308666744-24d5c474f2ae?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwyfHxtZW50aG9sJTIwaW5oYWxlcnxlbnwxfHx8fDE3NjA4OTQ2MjB8MA&ixlib=rb-4.1.0&q=80&w=1080',
        inStock: true,
      },
    ];

    for (const product of demoProducts) {
      await kv.set(`product:${product.id}`, product);
    }

    return c.json({ success: true, message: 'Demo data initialized', count: demoProducts.length });
  } catch (error) {
    console.error('Error initializing demo data:', error);
    return c.json({ error: 'Failed to initialize demo data' }, 500);
  }
});

// Create first admin user
app.post('/make-server-a75b5353/create-admin', async (c) => {
  try {
    const { email, password, name } = await c.req.json();
    
    if (!email || !password) {
      return c.json({ error: 'Email and password are required' }, 400);
    }
    
    const supabase = getSupabaseAdmin();
    
    console.log(`üë§ Creating admin user: ${email}`);
    
    // Create admin user
    const { data, error } = await supabase.auth.admin.createUser({
      email,
      password,
      user_metadata: { 
        name: name || 'Admin',
        isAdmin: true,
        isWholesaler: false
      },
      email_confirm: true,
    });

    if (error) {
      console.error('‚ùå Create admin auth error:', error);
      return c.json({ error: error.message }, 400);
    }

    console.log(`‚úÖ Admin auth user created: ${data.user.id}`);

    // Create admin profile in database
    const { error: profileError } = await supabase
      .from('profiles')
      .insert([{
        id: data.user.id,
        email: email,
        name: name || 'Admin',
        is_admin: true,
        is_wholesaler: false,
        loyalty_points: 0,
        loyalty_tier: 'basic',
        monthly_total: 0,
      }]);

    if (profileError) {
      console.error('‚ùå Profile creation error:', profileError);
      // Check if profile already exists
      const { data: existingProfile } = await supabase
        .from('profiles')
        .select('id')
        .eq('id', data.user.id)
        .single();
      
      if (existingProfile) {
        console.log('‚ÑπÔ∏è Profile already exists, updating to admin');
        // Update existing profile to be admin
        await supabase
          .from('profiles')
          .update({ is_admin: true })
          .eq('id', data.user.id);
      } else {
        console.error('‚ö†Ô∏è Failed to create profile, but user auth was created');
        return c.json({ 
          error: 'Profile creation failed', 
          details: profileError.message 
        }, 500);
      }
    } else {
      console.log(`‚úÖ Admin profile created for: ${data.user.id}`);
    }

    return c.json({ 
      success: true, 
      user: {
        id: data.user.id,
        email: data.user.email,
        isAdmin: true
      }
    });
  } catch (error) {
    console.error('‚ùå Create admin exception:', error);
    return c.json({ error: 'Failed to create admin user', details: String(error) }, 500);
  }
});

// Auto-translate text using Google Translate (unofficial API)
app.post('/make-server-a75b5353/translate', requireAdmin, async (c) => {
  try {
    const { text, targetLang } = await c.req.json();
    
    if (!text || !targetLang) {
      console.error('‚ùå Missing text or targetLang');
      return c.json({ error: 'Text and target language required' }, 400);
    }

    console.log(`üåê Translating to ${targetLang}: "${text.substring(0, 50)}..."`);

    // Map our language codes to standard ISO codes
    const langMap: Record<string, string> = {
      'en': 'en',
      'zh': 'zh-CN',
      'vi': 'vi',
    };
    
    const targetLangCode = langMap[targetLang] || targetLang;

    // Method 1: Try Google Translate (free unofficial API)
    try {
      console.log(`üîÑ Trying Google Translate API...`);
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      // Using unofficial Google Translate API
      const googleTranslateUrl = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=ru&tl=${targetLangCode}&dt=t&q=${encodeURIComponent(text)}`;
      
      const response = await fetch(googleTranslateUrl, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'Mozilla/5.0',
        },
        signal: controller.signal,
      });
      
      clearTimeout(timeoutId);

      if (response.ok) {
        const data = await response.json();
        
        // Google Translate unofficial API returns array format: [[[translated_text, original_text, null, null, relevance]]]
        if (data && data[0] && Array.isArray(data[0])) {
          let translated = '';
          for (const segment of data[0]) {
            if (segment && segment[0]) {
              translated += segment[0];
            }
          }
          
          if (translated) {
            console.log(`‚úÖ Google Translate successful: "${translated.substring(0, 50)}..."`);
            return c.json({ translatedText: translated });
          }
        }
      }
    } catch (googleError) {
      console.warn('‚ö†Ô∏è Google Translate API failed:', googleError);
    }

    // Method 2: Try MyMemory as fallback
    try {
      console.log(`üîÑ Trying MyMemory API as fallback...`);
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 8000);
      
      const myMemoryUrl = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=ru|${targetLangCode}`;
      
      const response = await fetch(myMemoryUrl, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
        },
        signal: controller.signal,
      });
      
      clearTimeout(timeoutId);

      if (response.ok) {
        const data = await response.json();
        
        if (data.responseData && data.responseData.translatedText) {
          const translated = data.responseData.translatedText;
          console.log(`‚úÖ MyMemory translation successful: "${translated.substring(0, 50)}..."`);
          return c.json({ translatedText: translated });
        }
      }
    } catch (myMemoryError) {
      console.warn('‚ö†Ô∏è MyMemory API failed:', myMemoryError);
    }

    // Fallback: Return original text
    console.warn('‚ö†Ô∏è All translation services failed, returning original text');
    return c.json({ 
      translatedText: text,
      warning: 'Translation service timeout or error'
    });
  } catch (error) {
    console.error('‚ùå Translation error:', error);
    return c.json({ error: 'Translation failed', details: String(error) }, 500);
  }
});

// ============================================
// Page Content Endpoints
// ============================================

// Get page content (public)
app.get('/make-server-a75b5353/pages/:pageName', async (c) => {
  try {
    const pageName = c.req.param('pageName');
    const lang = c.req.query('lang') || 'ru';
    
    console.log(`üìÑ Fetching page content: ${pageName} (${lang})`);
    
    // Try to get content from KV store
    const contentKey = `page:${pageName}:${lang}`;
    const content = await kv.get(contentKey);
    
    if (content) {
      console.log(`‚úÖ Found content for ${pageName} in ${lang}`);
      return c.json({ content });
    }
    
    // Return empty if not found - frontend will use defaults
    console.log(`‚ö†Ô∏è No content found for ${pageName} in ${lang}, frontend will use defaults`);
    return c.json({ content: null });
  } catch (error) {
    console.error('‚ùå Error fetching page content:', error);
    return c.json({ error: 'Failed to fetch page content', details: String(error) }, 500);
  }
});

// Update page content (admin only)
app.post('/make-server-a75b5353/pages/:pageName', requireAdmin, async (c) => {
  try {
    const pageName = c.req.param('pageName');
    const { content, language } = await c.req.json();
    
    console.log(`üìù Updating page content: ${pageName} (${language})`);
    
    const contentKey = `page:${pageName}:${language}`;
    await kv.set(contentKey, content);
    
    console.log(`‚úÖ Updated content for ${pageName} in ${language}`);
    return c.json({ success: true });
  } catch (error) {
    console.error('‚ùå Error updating page content:', error);
    return c.json({ error: 'Failed to update page content', details: String(error) }, 500);
  }
});

// ============================================
// Settings Endpoints (Admin Only)
// ============================================

// Get SEO settings (admin only)
app.get('/make-server-a75b5353/admin/settings/seo', requireAdmin, async (c) => {
  try {
    console.log('üìã Fetching SEO settings');
    
    const value = await kv.get('setting:seo');
    
    if (!value) {
      console.log('‚ö†Ô∏è SEO settings not found, returning defaults');
      return c.json({ value: null });
    }
    
    console.log('‚úÖ SEO settings found');
    return c.json({ value });
  } catch (error) {
    console.error('‚ùå Error fetching SEO settings:', error);
    return c.json({ error: 'Failed to fetch SEO settings', details: String(error) }, 500);
  }
});

// Update SEO settings (admin only)
app.put('/make-server-a75b5353/admin/settings/seo', requireAdmin, async (c) => {
  try {
    const { value } = await c.req.json();
    
    console.log('üìù Updating SEO settings');
    
    await kv.set('setting:seo', value);
    
    console.log('‚úÖ SEO settings updated successfully');
    return c.json({ success: true });
  } catch (error) {
    console.error('‚ùå Error updating SEO settings:', error);
    return c.json({ error: 'Failed to update SEO settings', details: String(error) }, 500);
  }
});

// Get all settings (admin only)
app.get('/make-server-a75b5353/admin/settings', requireAdmin, async (c) => {
  try {
    console.log('üìã Fetching all settings');
    
    const settingsData = await kv.getByPrefix('setting:');
    
    // Convert array of {key, value} to object
    const settings: Record<string, any> = {};
    for (const item of settingsData) {
      // Extract setting name from key (format: "setting:name")
      const settingName = item.key.replace('setting:', '');
      settings[settingName] = item.value;
    }
    
    console.log(`‚úÖ Fetched ${Object.keys(settings).length} settings`);
    return c.json({ settings });
  } catch (error) {
    console.error('‚ùå Error fetching settings:', error);
    return c.json({ error: 'Failed to fetch settings', details: String(error) }, 500);
  }
});

// Get specific setting (admin only)
app.get('/make-server-a75b5353/admin/settings/:name', requireAdmin, async (c) => {
  try {
    const settingName = c.req.param('name');
    console.log(`üìã Fetching setting: ${settingName}`);
    
    const value = await kv.get(`setting:${settingName}`);
    
    if (value === null || value === undefined) {
      console.log(`‚ö†Ô∏è Setting not found: ${settingName}`);
      return c.json({ value: null });
    }
    
    console.log(`‚úÖ Found setting: ${settingName}`);
    return c.json({ value });
  } catch (error) {
    console.error('‚ùå Error fetching setting:', error);
    return c.json({ error: 'Failed to fetch setting', details: String(error) }, 500);
  }
});

// Update setting (admin only)
app.put('/make-server-a75b5353/admin/settings/:name', requireAdmin, async (c) => {
  try {
    const settingName = c.req.param('name');
    const { value } = await c.req.json();
    
    console.log(`üìù Updating setting: ${settingName}`);
    
    await kv.set(`setting:${settingName}`, value);
    
    console.log(`‚úÖ Updated setting: ${settingName}`);
    return c.json({ success: true });
  } catch (error) {
    console.error('‚ùå Error updating setting:', error);
    return c.json({ error: 'Failed to update setting', details: String(error) }, 500);
  }
});

// ============================================
// Category Management Endpoints
// ============================================

// Get categories (public endpoint for frontend, admin endpoint for management)
app.get('/make-server-a75b5353/admin/categories', async (c) => {
  try {
    console.log('üìã Fetching categories');
    
    let categories = await kv.get('categories');
    
    if (!categories) {
      console.log('‚ÑπÔ∏è No categories found, initializing default categories');
      
      // Default categories matching the existing structure
      categories = {
        topMenu: [
          {
            id: 'ointments',
            translations: {
              ru: '–ú–∞–∑–∏ –∏ –±–∞–ª—å–∑–∞–º—ã',
              en: 'Ointments and Balms',
              zh: 'ËçØËÜèÂíåÈ¶ôËÜè',
              vi: 'Thu·ªëc m·ª° v√† d·∫ßu b√¥i'
            },
            order: 0
          },
          {
            id: 'patches',
            translations: {
              ru: '–ü–ª–∞—Å—Ç—ã—Ä–∏',
              en: 'Patches',
              zh: 'Ë¥¥ËÜè',
              vi: 'Mi·∫øng d√°n'
            },
            order: 1
          },
          {
            id: 'elixirs',
            translations: {
              ru: '–≠ÔøΩÔøΩ–∏–∫—Å–∏—Ä—ã',
              en: 'Elixirs',
              zh: 'ÁÅµ‰∏πÂ¶ôËçØ',
              vi: 'Thu·ªëc ti√™n'
            },
            order: 2
          },
          {
            id: 'capsules',
            translations: {
              ru: '–ö–∞–ø—Å—É–ª—ã –∏ –ø–∏–ª—é–ª–∏',
              en: 'Capsules and Pills',
              zh: 'ËÉ∂ÂõäÂíå‰∏∏ÂâÇ',
              vi: 'Vi√™n nang v√† vi√™n thu·ªëc'
            },
            order: 3
          },
          {
            id: 'teas',
            translations: {
              ru: '–õ–µ—á–µ–±–Ω—ã–µ —á–∞–∏',
              en: 'Herbal Teas',
              zh: 'ËçâËçØËå∂',
              vi: 'Tr√† th·∫£o d∆∞·ª£c'
            },
            order: 4
          },
          {
            id: 'oils',
            translations: {
              ru: '–ú–∞—Å–ª–∞',
              en: 'Oils',
              zh: 'Ê≤π',
              vi: 'D·∫ßu'
            },
            order: 5
          },
          {
            id: 'drops',
            translations: {
              ru: '–ö–∞–ø–ª–∏',
              en: 'Drops',
              zh: 'Êª¥ÂâÇ',
              vi: 'Thu·ªëc nh·ªè'
            },
            order: 6
          },
          {
            id: 'samples',
            translations: {
              ru: '–ü—Ä–æ–±–Ω–∏–∫–∏',
              en: 'Samples',
              zh: 'Ê†∑ÂìÅ',
              vi: 'M·∫´u th·ª≠'
            },
            order: 7
          },
          {
            id: 'other',
            translations: {
              ru: '–î—Ä—É–≥–æ–µ',
              en: 'Other',
              zh: 'ÂÖ∂‰ªñ',
              vi: 'Kh√°c'
            },
            order: 8
          }
        ],
        sidebar: [
          {
            id: 'popular',
            translations: {
              ru: '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã',
              en: 'Popular Products',
              zh: 'ÁÉ≠Èó®‰∫ßÂìÅ',
              vi: 'S·∫£n ph·∫©m ph·ªï bi·∫øn'
            },
            icon: 'Star',
            order: 0
          },
          {
            id: 'cold',
            translations: {
              ru: '–ü—Ä–æ—Å—Ç—É–¥–∞',
              en: 'Cold',
              zh: 'ÊÑüÂÜí',
              vi: 'C·∫£m l·∫°nh'
            },
            icon: 'Thermometer',
            order: 1
          },
          {
            id: 'digestive',
            translations: {
              ru: '–ñ–ö–¢',
              en: 'Digestive System',
              zh: 'Ê∂àÂåñÁ≥ªÁªü',
              vi: 'H·ªá ti√™u h√≥a'
            },
            icon: 'Activity',
            order: 2
          },
          {
            id: 'skin',
            translations: {
              ru: '–ë–æ–ª–µ–∑–Ω–∏ –∫–æ–∂–∏',
              en: 'Skin Diseases',
              zh: 'ÁöÆËÇ§ÁóÖ',
              vi: 'B·ªánh da'
            },
            icon: 'Droplet',
            order: 3
          },
          {
            id: 'joints',
            translations: {
              ru: '–°—É—Å—Ç–∞–≤—ã',
              en: 'Joints',
              zh: 'ÂÖ≥ËäÇ',
              vi: 'Kh·ªõp'
            },
            icon: 'Bone',
            order: 4
          },
          {
            id: 'headache',
            translations: {
              ru: '–ì–æ–ª–æ–≤–Ω–∞—è –±–æ–ª—å',
              en: 'Headache',
              zh: 'Â§¥Áóõ',
              vi: 'ƒêau ƒë·∫ßu'
            },
            icon: 'Brain',
            order: 5
          },
          {
            id: 'heart',
            translations: {
              ru: '–°–µ—Ä–¥—Ü–µ –∏ —Å–æ—Å—É–¥—ã',
              en: 'Heart and Vessels',
              zh: 'ÂøÉËÑèÂíåË°ÄÁÆ°',
              vi: 'Tim m·∫°ch'
            },
            icon: 'Heart',
            order: 6
          },
          {
            id: 'liver',
            translations: {
              ru: '–ü–µ—á–µ–Ω—å',
              en: 'Liver',
              zh: 'ËÇùËÑè',
              vi: 'Gan'
            },
            icon: 'Leaf',
            order: 7
          },
          {
            id: 'oncology',
            translations: {
              ru: '–û–Ω–∫–æ–ª–æ–≥–∏—è',
              en: 'Oncology',
              zh: 'ËÇøÁò§Áßë',
              vi: 'Ung th∆∞'
            },
            icon: 'Shield',
            order: 8
          },
          {
            id: 'kidneys',
            translations: {
              ru: '–ü–æ—á–∫–∏',
              en: 'Kidneys',
              zh: 'ËÇæËÑè',
              vi: 'Th·∫≠n'
            },
            icon: 'Droplet',
            order: 9
          },
          {
            id: 'nervous',
            translations: {
              ru: '–ù–µ—Ä–≤–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞',
              en: 'Nervous System',
              zh: 'Á•ûÁªèÁ≥ªÁªü',
              vi: 'H·ªá th·∫ßn kinh'
            },
            icon: 'Zap',
            order: 10
          },
          {
            id: 'womensHealth',
            translations: {
              ru: '–ñ–µ–Ω—Å–∫–æ–µ –∑–¥–æ—Ä–æ–≤—å–µ',
              en: "Women's Health",
              zh: 'Â•≥ÊÄßÂÅ•Â∫∑',
              vi: 'S·ª©c kh·ªèe ph·ª• n·ªØ'
            },
            icon: 'User',
            order: 11
          },
          {
            id: 'mensHealth',
            translations: {
              ru: '–ú—É–∂—Å–∫–æ–µ –∑–¥–æ—Ä–æ–≤—å–µ',
              en: "Men's Health",
              zh: 'Áî∑ÊÄßÂÅ•Â∫∑',
              vi: 'S·ª©c kh·ªèe nam gi·ªõi'
            },
            icon: 'User',
            order: 12
          },
          {
            id: 'forChildren',
            translations: {
              ru: '–î–ª—è –¥–µÔøΩÔøΩ–µ–π',
              en: 'For Children',
              zh: 'ÂÑøÁ´•',
              vi: 'Cho tr·∫ª em'
            },
            icon: 'Baby',
            order: 13
          },
          {
            id: 'vision',
            translations: {
              ru: '–ó—Ä–µ–Ω–∏–µ',
              en: 'Vision',
              zh: 'ËßÜÂäõ',
              vi: 'Th·ªã l·ª±c'
            },
            icon: 'Eye',
            order: 14
          },
          {
            id: 'hemorrhoids',
            translations: {
              ru: '–ì–µ–º–æ—Ä—Ä–æ–π',
              en: 'Hemorrhoids',
              zh: 'ÁóîÁñÆ',
              vi: 'Trƒ©'
            },
            icon: 'CircleDot',
            order: 15
          }
        ]
      };
      
      // Save default categories
      await kv.set('categories', categories);
      console.log('‚úÖ Default categories initialized');
    }
    
    console.log('‚úÖ Categories loaded');
    return c.json({ categories });
  } catch (error) {
    console.error('‚ùå Error fetching categories:', error);
    return c.json({ error: 'Failed to fetch categories', details: String(error) }, 500);
  }
});

// Public endpoint to get categories (no auth required)
app.get('/make-server-a75b5353/categories', async (c) => {
  try {
    console.log('üìã Fetching categories (public)');
    
    let categories = await kv.get('categories');
    
    if (!categories) {
      console.log('‚ÑπÔ∏è No categories found, initializing default categories');
      
      // Default categories with proper translations for all languages
      categories = {
        topMenu: [
          {
            id: 'ointments',
            translations: {
              ru: '–ú–∞–∑–∏ –∏ –±–∞–ª—å–∑–∞–º—ã',
              en: 'Ointments & Balms',
              zh: 'ËçØËÜèÂíåÈ¶ôËÜè',
              vi: 'Thu·ªëc m·ª° v√† d·∫ßu b√¥i'
            },
            order: 0
          },
          {
            id: 'patches',
            translations: {
              ru: '–ü–ª–∞—Å—Ç—ã—Ä–∏',
              en: 'Patches',
              zh: 'Ë¥¥ËÜè',
              vi: 'Mi·∫øng d√°n'
            },
            order: 1
          },
          {
            id: 'sprays',
            translations: {
              ru: '–°–ø—Ä–µ–∏',
              en: 'Sprays',
              zh: 'Âñ∑ÂâÇ',
              vi: 'X·ªãt'
            },
            order: 2
          },
          {
            id: 'teas',
            translations: {
              ru: '–ß–∞–π',
              en: 'Tea',
              zh: 'Ëå∂',
              vi: 'Tr√†'
            },
            order: 3
          },
          {
            id: 'elixirs',
            translations: {
              ru: '–≠–ª–∏–∫—Å–∏—Ä—ã',
              en: 'Elixirs',
              zh: 'ËçØÈÖí',
              vi: 'Thu·ªëc b·ªï'
            },
            order: 4
          },
          {
            id: 'pills',
            translations: {
              ru: '–ü–∏–ª—é–ª–∏',
              en: 'Pills',
              zh: '‰∏∏ËçØ',
              vi: 'Vi√™n thu·ªëc'
            },
            order: 5
          },
          {
            id: 'cosmetics',
            translations: {
              ru: '–ö–æ—Å–º–µ—Ç–∏–∫–∞',
              en: 'Cosmetics',
              zh: 'ÂåñÂ¶ÜÂìÅ',
              vi: 'M·ªπ ph·∫©m'
            },
            order: 6
          }
        ],
        sidebar: [
          {
            id: 'popular',
            translations: {
              ru: '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã',
              en: 'Popular Products',
              zh: 'ÁÉ≠Èó®‰∫ßÂìÅ',
              vi: 'S·∫£n ph·∫©m ph·ªï bi·∫øn'
            },
            icon: 'Sparkles',
            order: 0
          },
          {
            id: 'allProducts',
            translations: {
              ru: '–í—Å–µ —Ç–æ–≤–∞—Ä—ã',
              en: 'All Products',
              zh: 'ÊâÄÊúâ‰∫ßÂìÅ',
              vi: 'T·∫•t c·∫£ s·∫£n ph·∫©m'
            },
            icon: 'Package',
            order: 1
          },
          {
            id: 'cold',
            translations: {
              ru: '–ü—Ä–æ—Å—Ç—É–¥–∞',
              en: 'Cold & Flu',
              zh: 'ÊÑüÂÜí',
              vi: 'C·∫£m l·∫°nh'
            },
            icon: 'Thermometer',
            order: 2
          },
          {
            id: 'digestive',
            translations: {
              ru: '–ñ–ö–¢',
              en: 'Digestive System',
              zh: 'Ê∂àÂåñÁ≥ªÁªü',
              vi: 'H·ªá ti√™u h√≥a'
            },
            icon: 'Activity',
            order: 3
          },
          {
            id: 'skin',
            translations: {
              ru: '–ö–æ–∂–∞',
              en: 'Skin',
              zh: 'ÁöÆËÇ§',
              vi: 'Da'
            },
            icon: 'Droplet',
            order: 4
          },
          {
            id: 'joints',
            translations: {
              ru: '–°—É—Å—Ç–∞–≤—ã',
              en: 'Joints',
              zh: 'ÂÖ≥ËäÇ',
              vi: 'Kh·ªõp'
            },
            icon: 'Bone',
            order: 5
          },
          {
            id: 'heart',
            translations: {
              ru: '–°–µ—Ä–¥—Ü–µ –∏ —Å–æ—Å—É–¥—ã',
              en: 'Heart & Vessels',
              zh: 'ÂøÉËÑèÂíåË°ÄÁÆ°',
              vi: 'Tim m·∫°ch'
            },
            icon: 'Heart',
            order: 6
          },
          {
            id: 'liverKidneys',
            translations: {
              ru: '–ü–µ—á–µ–Ω—å –∏ –ø–æ—á–∫–∏',
              en: 'Liver & Kidneys',
              zh: 'ËÇùËÇæ',
              vi: 'Gan th·∫≠n'
            },
            icon: 'Leaf',
            order: 7
          },
          {
            id: 'nervous',
            translations: {
              ru: '–ù–µ—Ä–≤–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞',
              en: 'Nervous System',
              zh: 'Á•ûÁªèÁ≥ªÁªü',
              vi: 'H·ªá th·∫ßn kinh'
            },
            icon: 'Zap',
            order: 8
          },
          {
            id: 'womensHealth',
            translations: {
              ru: '–ñ–µ–Ω—Å–∫–æ–µ –∑–¥–æ—Ä–æ–≤—å–µ',
              en: "Women's Health",
              zh: 'Â•≥ÊÄßÂÅ•Â∫∑',
              vi: 'S·ª©c kh·ªèe ph·ª• n·ªØ'
            },
            icon: 'User',
            order: 9
          },
          {
            id: 'mensHealth',
            translations: {
              ru: '–ú—É–∂—Å–∫–æ–µ –∑–¥–æ—Ä–æ–≤—å–µ',
              en: "Men's Health",
              zh: 'Áî∑ÊÄßÂÅ•Â∫∑',
              vi: 'S·ª©c kh·ªèe nam gi·ªõi'
            },
            icon: 'User',
            order: 10
          },
          {
            id: 'forChildren',
            translations: {
              ru: '–î–ª—è –¥–µ—Ç–µ–π',
              en: 'For Children',
              zh: 'ÂÑøÁ´•',
              vi: 'Cho tr·∫ª em'
            },
            icon: 'Baby',
            order: 11
          },
          {
            id: 'vision',
            translations: {
              ru: '–ó—Ä–µ–Ω–∏–µ',
              en: 'Vision',
              zh: 'ËßÜÂäõ',
              vi: 'Th·ªã l·ª±c'
            },
            icon: 'Eye',
            order: 12
          },
          {
            id: 'hemorrhoids',
            translations: {
              ru: '–ì–µ–º–æ—Ä—Ä–æ–π',
              en: 'Hemorrhoids',
              zh: 'ÁóîÁñÆ',
              vi: 'Trƒ©'
            },
            icon: 'CircleDot',
            order: 13
          },
          {
            id: 'oncology',
            translations: {
              ru: '–û–Ω–∫–æ–ª–æ–≥–∏—è',
              en: 'Oncology',
              zh: 'ËÇøÁò§',
              vi: 'Ung th∆∞'
            },
            icon: 'Shield',
            order: 14
          },
          {
            id: 'thyroid',
            translations: {
              ru: '–©–∏—Ç–æ–≤–∏–¥–Ω–∞—è –∂–µ–ª–µ–∑–∞',
              en: 'Thyroid',
              zh: 'Áî≤Áä∂ËÖ∫',
              vi: 'Tuy·∫øn gi√°p'
            },
            icon: 'Coffee',
            order: 15
          },
          {
            id: 'lungs',
            translations: {
              ru: '–õ–µ–≥–∫–∏–µ',
              en: 'Lungs',
              zh: 'ËÇ∫',
              vi: 'Ph·ªïi'
            },
            icon: 'Wind',
            order: 16
          }
        ]
      };
      
      // Save default categories
      await kv.set('categories', categories);
      console.log('‚úÖ Default categories initialized in public endpoint');
    }
    
    return c.json({ categories });
  } catch (error) {
    console.error('‚ùå Error fetching categories:', error);
    return c.json({ error: 'Failed to fetch categories', details: String(error) }, 500);
  }
});

// Update categories (admin only)
app.put('/make-server-a75b5353/admin/categories', requireAdmin, async (c) => {
  try {
    const { categories } = await c.req.json();
    
    console.log('üìù Updating categories');
    
    await kv.set('categories', categories);
    
    console.log('‚úÖ Categories updated successfully');
    return c.json({ success: true });
  } catch (error) {
    console.error('‚ùå Error updating categories:', error);
    return c.json({ error: 'Failed to update categories', details: String(error) }, 500);
  }
});

// Force reset categories to defaults (admin only) - Complete wipe and recreation
app.post('/make-server-a75b5353/admin/categories/reset-all', requireAdmin, async (c) => {
  try {
    console.log('üîÑ FORCE RESETTING ALL CATEGORIES - Complete wipe and recreation');
    
    // Delete existing categories completely
    await kv.del('categories');
    console.log('‚úÖ Old categories deleted');
    
    // Create fresh default categories with proper translations
    const freshCategories = {
      topMenu: [
        {
          id: 'ointments',
          translations: {
            ru: '–ú–∞–∑–∏ –∏ –±–∞–ª—å–∑–∞–º—ã',
            en: 'Ointments & Balms',
            zh: 'ËçØËÜèÂíåÈ¶ôËÜè',
            vi: 'Thu·ªëc m·ª° v√† d·∫ßu b√¥i'
          },
          order: 0
        },
        {
          id: 'patches',
          translations: {
            ru: '–ü–ª–∞—Å—Ç—ã—Ä–∏',
            en: 'Patches',
            zh: 'Ë¥¥ËÜè',
            vi: 'Mi·∫øng d√°n'
          },
          order: 1
        },
        {
          id: 'sprays',
          translations: {
            ru: '–°–ø—Ä–µ–∏',
            en: 'Sprays',
            zh: 'Âñ∑ÂâÇ',
            vi: 'X·ªãt'
          },
          order: 2
        },
        {
          id: 'teas',
          translations: {
            ru: '–ß–∞–π',
            en: 'Tea',
            zh: 'Ëå∂',
            vi: 'Tr√†'
          },
          order: 3
        },
        {
          id: 'elixirs',
          translations: {
            ru: '–≠–ª–∏–∫—Å–∏—Ä—ã',
            en: 'Elixirs',
            zh: 'ËçØÈÖí',
            vi: 'Thu·ªëc b·ªï'
          },
          order: 4
        },
        {
          id: 'pills',
          translations: {
            ru: '–ü–∏–ª—é–ª–∏',
            en: 'Pills',
            zh: '‰∏∏ËçØ',
            vi: 'Vi√™n thu·ªëc'
          },
          order: 5
        },
        {
          id: 'cosmetics',
          translations: {
            ru: '–ö–æ—Å–º–µ—Ç–∏–∫–∞',
            en: 'Cosmetics',
            zh: 'ÂåñÂ¶ÜÂìÅ',
            vi: 'M·ªπ ph·∫©m'
          },
          order: 6
        }
      ],
      sidebar: [
        {
          id: 'popular',
          translations: {
            ru: '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã',
            en: 'Popular Products',
            zh: 'ÁÉ≠Èó®‰∫ßÂìÅ',
            vi: 'S·∫£n ph·∫©m ph·ªï bi·∫øn'
          },
          icon: 'Sparkles',
          order: 0
        },
        {
          id: 'allProducts',
          translations: {
            ru: '–í—Å–µ —Ç–æ–≤–∞—Ä—ã',
            en: 'All Products',
            zh: 'ÊâÄÊúâ‰∫ßÂìÅ',
            vi: 'T·∫•t c·∫£ s·∫£n ph·∫©m'
          },
          icon: 'Package',
          order: 1
        },
        {
          id: 'cold',
          translations: {
            ru: '–ü—Ä–æ—Å—Ç—É–¥–∞',
            en: 'Cold & Flu',
            zh: 'ÊÑüÂÜí',
            vi: 'C·∫£m l·∫°nh'
          },
          icon: 'Thermometer',
          order: 2
        },
        {
          id: 'digestive',
          translations: {
            ru: '–ñ–ö–¢',
            en: 'Digestive System',
            zh: 'Ê∂àÂåñÁ≥ªÁªü',
            vi: 'H·ªá ti√™u h√≥a'
          },
          icon: 'Activity',
          order: 3
        },
        {
          id: 'skin',
          translations: {
            ru: '–ö–æ–∂–∞',
            en: 'Skin',
            zh: 'ÁöÆËÇ§',
            vi: 'Da'
          },
          icon: 'Droplet',
          order: 4
        },
        {
          id: 'joints',
          translations: {
            ru: '–°—É—Å—Ç–∞–≤—ã',
            en: 'Joints',
            zh: 'ÂÖ≥ËäÇ',
            vi: 'Kh·ªõp'
          },
          icon: 'Bone',
          order: 5
        },
        {
          id: 'heart',
          translations: {
            ru: '–°–µ—Ä–¥—Ü–µ –∏ —Å–æ—Å—É–¥—ã',
            en: 'Heart & Vessels',
            zh: 'ÂøÉËÑèÂíåË°ÄÁÆ°',
            vi: 'Tim m·∫°ch'
          },
          icon: 'Heart',
          order: 6
        },
        {
          id: 'liverKidneys',
          translations: {
            ru: '–ü–µ—á–µ–Ω—å –∏ –ø–æ—á–∫–∏',
            en: 'Liver & Kidneys',
            zh: 'ËÇùËÇæ',
            vi: 'Gan th·∫≠n'
          },
          icon: 'Leaf',
          order: 7
        },
        {
          id: 'nervous',
          translations: {
            ru: '–ù–µ—Ä–≤–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞',
            en: 'Nervous System',
            zh: 'Á•ûÁªèÁ≥ªÁªü',
            vi: 'H·ªá th·∫ßn kinh'
          },
          icon: 'Zap',
          order: 8
        },
        {
          id: 'womensHealth',
          translations: {
            ru: '–ñ–µ–Ω—Å–∫–æ–µ –∑–¥–æ—Ä–æ–≤—å–µ',
            en: "Women's Health",
            zh: 'Â•≥ÊÄßÂÅ•Â∫∑',
            vi: 'S·ª©c kh·ªèe ph·ª• n·ªØ'
          },
          icon: 'User',
          order: 9
        },
        {
          id: 'mensHealth',
          translations: {
            ru: '–ú—É–∂—Å–∫–æ–µ –∑–¥–æ—Ä–æ–≤—å–µ',
            en: "Men's Health",
            zh: 'Áî∑ÊÄßÂÅ•Â∫∑',
            vi: 'S·ª©c kh·ªèe nam gi·ªõi'
          },
          icon: 'User',
          order: 10
        },
        {
          id: 'forChildren',
          translations: {
            ru: '–î–ª—è –¥–µ—Ç–µ–π',
            en: 'For Children',
            zh: 'ÂÑøÁ´•',
            vi: 'Cho tr·∫ª em'
          },
          icon: 'Baby',
          order: 11
        },
        {
          id: 'vision',
          translations: {
            ru: '–ó—Ä–µ–Ω–∏–µ',
            en: 'Vision',
            zh: 'ËßÜÂäõ',
            vi: 'Th·ªã l·ª±c'
          },
          icon: 'Eye',
          order: 12
        },
        {
          id: 'hemorrhoids',
          translations: {
            ru: '–ì–µ–º–æ—Ä—Ä–æ–π',
            en: 'Hemorrhoids',
            zh: 'ÁóîÁñÆ',
            vi: 'Trƒ©'
          },
          icon: 'CircleDot',
          order: 13
        },
        {
          id: 'oncology',
          translations: {
            ru: '–û–Ω–∫–æ–ª–æ–≥–∏—è',
            en: 'Oncology',
            zh: 'ËÇøÁò§',
            vi: 'Ung th∆∞'
          },
          icon: 'Shield',
          order: 14
        },
        {
          id: 'thyroid',
          translations: {
            ru: '–©–∏—Ç–æ–≤–∏–¥–Ω–∞—è –∂–µ–ª–µ–∑–∞',
            en: 'Thyroid',
            zh: 'Áî≤Áä∂ËÖ∫',
            vi: 'Tuy·∫øn gi√°p'
          },
          icon: 'Coffee',
          order: 15
        },
        {
          id: 'lungs',
          translations: {
            ru: '–õ–µ–≥–∫–∏–µ',
            en: 'Lungs',
            zh: 'ËÇ∫',
            vi: 'Ph·ªïi'
          },
          icon: 'Wind',
          order: 16
        }
      ]
    };
    
    // Save fresh categories
    await kv.set('categories', freshCategories);
    console.log('‚úÖ Fresh categories created with proper translations');
    
    return c.json({ 
      success: true, 
      categories: freshCategories,
      message: 'Categories completely reset to defaults with proper translations' 
    });
  } catch (error) {
    console.error('‚ùå Error resetting categories:', error);
    return c.json({ error: 'Failed to reset categories', details: String(error) }, 500);
  }
});

// ============================================
// Settings Endpoints (continued)
// ============================================

// Update multiple settings at once (admin only)
app.post('/make-server-a75b5353/admin/settings', requireAdmin, async (c) => {
  try {
    const { settings } = await c.req.json();
    
    console.log(`üìù Updating ${Object.keys(settings).length} settings`);
    
    // Save each setting
    for (const [key, value] of Object.entries(settings)) {
      await kv.set(`setting:${key}`, value);
      console.log(`  ‚úì Saved ${key}`);
    }
    
    console.log(`‚úÖ All settings updated successfully`);
    return c.json({ success: true });
  } catch (error) {
    console.error('‚ùå Error updating settings:', error);
    return c.json({ error: 'Failed to update settings', details: String(error) }, 500);
  }
});

// ============================================
// Analytics Endpoint
// ============================================

// Get analytics data (admin only)
app.get('/make-server-a75b5353/admin/analytics', requireAdmin, async (c) => {
  try {
    console.log('üìä Fetching analytics data');
    
    // Get all orders
    const allOrders = await kv.getByPrefix('order:');
    const orders = allOrders.map(o => o.value);
    
    // Get all users
    const allUsers = await kv.getByPrefix('user:');
    const users = allUsers.map(u => u.value);
    
    // Today's date boundaries
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    // Yesterday's date boundaries
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    // Filter orders by date
    const todayOrders = orders.filter(o => {
      const orderDate = new Date(o.createdAt || o.orderDate);
      return orderDate >= today && orderDate < tomorrow;
    });
    
    const yesterdayOrders = orders.filter(o => {
      const orderDate = new Date(o.createdAt || o.orderDate);
      return orderDate >= yesterday && orderDate < today;
    });
    
    // Calculate revenue
    const revenueToday = todayOrders.reduce((sum, o) => sum + (o.totalPrice || 0), 0);
    const revenueYesterday = yesterdayOrders.reduce((sum, o) => sum + (o.totalPrice || 0), 0);
    
    // New customers today
    const newCustomersToday = users.filter(u => {
      const createdDate = new Date(u.createdAt || u.created_at);
      return createdDate >= today && createdDate < tomorrow;
    }).length;
    
    // Loyalty points issued today
    const loyaltyPointsToday = todayOrders.reduce((sum, o) => {
      // Rough estimate: 5% of order value as points
      return sum + Math.floor((o.totalPrice || 0) * 0.05);
    }, 0);
    
    // Store statistics
    const storeStats = {
      china: { orders: 0, revenue: 0 },
      thailand: { orders: 0, revenue: 0 },
      vietnam: { orders: 0, revenue: 0 },
    };
    
    todayOrders.forEach(order => {
      const store = order.store || 'china';
      if (storeStats[store as keyof typeof storeStats]) {
        storeStats[store as keyof typeof storeStats].orders += 1;
        storeStats[store as keyof typeof storeStats].revenue += order.totalPrice || 0;
      }
    });
    
    const analyticsData = {
      ordersToday: todayOrders.length,
      revenueToday,
      newCustomers: newCustomersToday,
      loyaltyPointsIssued: loyaltyPointsToday,
      ordersYesterday: yesterdayOrders.length,
      revenueYesterday,
      storeStats,
    };
    
    console.log(`‚úÖ Analytics calculated: ${todayOrders.length} orders today, ${revenueToday} ‚ÇΩ revenue`);
    return c.json(analyticsData);
  } catch (error) {
    console.error('‚ùå Error fetching analytics:', error);
    return c.json({ error: 'Failed to fetch analytics', details: String(error) }, 500);
  }
});

// ============================================
// WordPress Parser Endpoint
// ============================================

// Parse WordPress products (admin only)
app.post('/make-server-a75b5353/admin/parse-wordpress', requireAdmin, async (c) => {
  try {
    const { url } = await c.req.json();
    
    if (!url) {
      return c.json({ error: 'URL is required' }, 400);
    }
    
    console.log(`üîç Parsing WordPress site: ${url}`);
    
    // Validate URL
    let inputUrl: URL;
    try {
      inputUrl = new URL(url);
    } catch (e) {
      return c.json({ 
        error: 'Invalid URL format',
        message: '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π URL. –ù–∞–ø—Ä–∏–º–µ—Ä: https://example.com'
      }, 400);
    }
    
    // Check if URL already contains WooCommerce API path with auth params
    let apiUrl: string;
    
    if (url.includes('/wp-json/wc/v3/products')) {
      // User provided full API URL with auth params
      apiUrl = url;
      console.log(`üì° Using provided API URL with authentication`);
    } else {
      // User provided just the site URL, construct API URL
      apiUrl = `${inputUrl.origin}/wp-json/wc/v3/products`;
      console.log(`üì° Constructed API URL: ${apiUrl}`);
    }
    
    console.log(`üîó Fetching from: ${apiUrl.replace(/consumer_key=[^&]+/, 'consumer_key=***').replace(/consumer_secret=[^&]+/, 'consumer_secret=***')}`);
    
    try {
      const response = await fetch(apiUrl, {
        headers: {
          'User-Agent': 'Asia-Pharm-Parser/1.0',
          'Accept': 'application/json',
        },
      });
      
      console.log(`üìä API Response Status: ${response.status}`);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.warn(`‚ö†Ô∏è WooCommerce API Error (${response.status}):`, errorText);
        
        let errorMessage = '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ WooCommerce REST API.';
        
        if (response.status === 401) {
          errorMessage = '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è. –î–æ–±–∞–≤—å—Ç–µ API –∫–ª—é—á–∏ –≤ URL:\n' +
                        'https://–≤–∞—à-—Å–∞–π—Ç.com/wp-json/wc/v3/products?consumer_key=ck_xxx&consumer_secret=cs_xxx\n\n' +
                        '–°–æ–∑–¥–∞–π—Ç–µ ÔøΩÔøΩ–ª—é—á–∏ –≤: WooCommerce ‚Üí –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí REST API';
        } else if (response.status === 404) {
          errorMessage = 'WooCommerce REST API –Ω–µ –Ω–∞–π–¥–µ–Ω. –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ:\n' +
                        '1. WooCommerce —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏ –∞–∫—Ç–∏–≤–µ–Ω\n' +
                        '2. URL –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π\n' +
                        '3. –°–∞–π—Ç –¥–æ—Å—Ç—É–ø–µ–Ω';
        } else if (response.status === 403) {
          errorMessage = '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞ API –∫–ª—é—á–µ–π (–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –º–∏–Ω–∏–º—É–º "Read")';
        }
        
        return c.json({ 
          error: 'WooCommerce API access denied', 
          message: errorMessage,
          status: response.status,
          details: errorText.substring(0, 200)
        }, 400);
      }
      
      const products = await response.json();
      
      // Check if response is actually an array of products
      if (!Array.isArray(products)) {
        console.error('‚ùå Response is not an array:', products);
        return c.json({
          error: 'Invalid API response',
          message: 'API –Ω–µ –≤–µ—Ä–Ω—É–ª —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ URL –∏ –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞.',
        }, 400);
      }
      
      console.log(`‚úÖ Found ${products.length} products`);
      
      // Parse and save products
      let savedCount = 0;
      for (const wpProduct of products) {
        try {
          // Convert WooCommerce product to our format
          const product = {
            id: crypto.randomUUID(),
            name: wpProduct.name || 'Unnamed Product',
            nameRu: wpProduct.name || '',
            nameEn: wpProduct.name || '',
            nameZh: wpProduct.name || '',
            nameVi: wpProduct.name || '',
            price: parseFloat(wpProduct.price) || 0,
            oldPrice: parseFloat(wpProduct.regular_price) || null,
            wholesalePrice: null,
            wholesalePriceYuan: null,
            image: wpProduct.images?.[0]?.src || '',
            images: wpProduct.images?.map((img: any) => img.src) || [],
            category: wpProduct.categories?.[0]?.name || 'Uncategorized',
            disease: '',
            description: wpProduct.description || '',
            descriptionRu: wpProduct.description || '',
            descriptionEn: wpProduct.description || '',
            descriptionZh: wpProduct.description || '',
            descriptionVi: wpProduct.description || '',
            stock: wpProduct.stock_quantity || 0,
            store: 'china', // Default store
            isSample: false,
            createdAt: new Date().toISOString(),
            wpId: wpProduct.id,
            wpPermalink: wpProduct.permalink,
          };
          
          await kv.set(`product:${product.id}`, product);
          savedCount++;
        } catch (productError) {
          console.error(`‚ùå Error saving product ${wpProduct.id}:`, productError);
        }
      }
      
      console.log(`‚úÖ Parsing complete: ${savedCount} products saved`);
      
      return c.json({ 
        success: true, 
        message: `–£—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ ${savedCount} —Ç–æ–≤–∞—Ä–æ–≤ –∏–∑ ${products.length}`,
        productsFound: products.length,
        productsSaved: savedCount,
      });
      
    } catch (fetchError) {
      console.error('‚ùå Error fetching from WordPress:', fetchError);
      return c.json({ 
        error: 'Failed to fetch products from WordPress',
        message: '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ —Å–∞–π—Ç –¥–æ—Å—Ç—É–ø–µ–Ω –∏ WooCommerce REST API –≤–∫–ª—é—á–µ–Ω.',
        details: String(fetchError)
      }, 500);
    }
  } catch (error) {
    console.error('‚ùå Error parsing WordPress:', error);
    return c.json({ error: 'Failed to parse WordPress site', details: String(error) }, 500);
  }
});

// ============================================
// CSV Catalog Import/Export Endpoints
// ============================================

// Export catalog to CSV (admin only)
app.get('/make-server-a75b5353/admin/catalog/export', requireAdmin, async (c) => {
  try {
    console.log('üì§ Exporting catalog to CSV');
    
    // Get all products from database
    const supabase = getSupabaseAdmin();
    const { data: products, error } = await supabase
      .from('products')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error('‚ùå Error fetching products:', error);
      return c.json({ error: 'Failed to fetch products', details: error.message }, 500);
    }
    
    console.log(`üì¶ Found ${products?.length || 0} products to export`);
    
    // CSV Headers
    const headers = [
      'id',
      'name_ru', 'name_en', 'name_zh', 'name_vi',
      'price_retail', 'price_wholesale',
      'weight',
      'category',
      'disease',
      'store',
      'image',
      'in_stock',
      'is_sample',
      'short_description_ru', 'short_description_en', 'short_description_zh', 'short_description_vi',
      'description_ru', 'description_en', 'description_zh', 'description_vi'
    ];
    
    // Escape CSV value (handle quotes, semicolons, newlines)
    const escapeCSV = (value: any): string => {
      if (value === null || value === undefined) return '';
      const str = String(value);
      // If contains semicolon, quote, or newline, wrap in quotes and escape internal quotes
      if (str.includes(';') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
        return `"${str.replace(/"/g, '""')}"`;
      }
      return str;
    };
    
    // Build CSV content with BOM for UTF-8 (for Excel)
    const BOM = '\uFEFF';
    let csvContent = BOM + headers.join(';') + '\n';
    
    if (products && products.length > 0) {
      products.forEach(product => {
        const row = [
          escapeCSV(product.id),
          escapeCSV(product.name || ''),
          escapeCSV(product.name_en || ''),
          escapeCSV(product.name_zh || ''),
          escapeCSV(product.name_vi || ''),
          escapeCSV(product.price || ''),
          escapeCSV(product.wholesale_price || ''),
          escapeCSV(product.weight || ''),
          escapeCSV(product.category || ''),
          escapeCSV(product.disease || ''),
          escapeCSV(product.store || ''),
          escapeCSV(product.image || ''),
          escapeCSV(product.in_stock !== false ? 'true' : 'false'),
          escapeCSV(product.is_sample === true ? 'true' : 'false'),
          escapeCSV(product.short_description || ''),
          escapeCSV(product.short_description_en || ''),
          escapeCSV(product.short_description_zh || ''),
          escapeCSV(product.short_description_vi || ''),
          escapeCSV(product.description || ''),
          escapeCSV(product.description_en || ''),
          escapeCSV(product.description_zh || ''),
          escapeCSV(product.description_vi || '')
        ];
        csvContent += row.join(';') + '\n';
      });
    }
    
    console.log('‚úÖ CSV content generated');
    
    // Return as CSV file with CORS headers
    return new Response(csvContent, {
      headers: {
        'Content-Type': 'text/csv; charset=utf-8',
        'Content-Disposition': `attachment; filename="catalog_export_${new Date().toISOString().split('T')[0]}.csv"`,
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      },
    });
  } catch (error) {
    console.error('‚ùå Error exporting catalog:', error);
    return c.json({ error: 'Failed to export catalog', details: String(error) }, 500);
  }
});

// Import catalog from CSV (admin only)
app.post('/make-server-a75b5353/admin/catalog/import', requireAdmin, async (c) => {
  try {
    console.log('üì• Importing catalog from CSV');
    
    const formData = await c.req.formData();
    const file = formData.get('file') as File;
    
    if (!file) {
      return c.json({ error: 'No file provided' }, 400);
    }
    
    const csvText = await file.text();
    // Remove BOM if present
    const cleanText = csvText.replace(/^\uFEFF/, '');
    const lines = cleanText.split('\n').filter(line => line.trim());
    
    if (lines.length < 2) {
      return c.json({ error: 'CSV file is empty or invalid' }, 400);
    }
    
    // Parse CSV
    const parseCSVLine = (line: string): string[] => {
      const result: string[] = [];
      let current = '';
      let inQuotes = false;
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        const nextChar = line[i + 1];
        
        if (char === '"') {
          if (inQuotes && nextChar === '"') {
            current += '"';
            i++; // Skip next quote
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === ';' && !inQuotes) {
          result.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }
      result.push(current.trim());
      return result;
    };
    
    const headers = parseCSVLine(lines[0]);
    console.log('üìã CSV Headers:', headers);
    
    let updated = 0;
    let created = 0;
    const errors: string[] = [];
    
    for (let i = 1; i < lines.length; i++) {
      try {
        const values = parseCSVLine(lines[i]);
        
        if (values.length < headers.length) {
          console.warn(`‚ö†Ô∏è Line ${i + 1}: Insufficient columns, skipping`);
          continue;
        }
        
        const product: any = {};
        headers.forEach((header, idx) => {
          product[header] = values[idx] || '';
        });
        
        // Build structured product object for database
        const supabase = getSupabaseAdmin();
        const isUpdate = !!product.id && product.id.trim() !== '';
        
        const dbProduct: any = {
          name: product.name_ru || '',
          name_en: product.name_en || '',
          name_zh: product.name_zh || '',
          name_vi: product.name_vi || '',
          price: parseFloat(product.price_retail) || 0,
          wholesale_price: parseFloat(product.price_wholesale) || null,
          weight: parseFloat(product.weight) || 0.1,
          category: product.category || 'other',
          disease: product.disease || 'other',
          store: product.store || 'china',
          image: product.image && product.image.trim() !== '' ? product.image.trim() : null,
          in_stock: product.in_stock !== 'false',
          is_sample: product.is_sample === 'true',
          short_description: product.short_description_ru || null,
          short_description_en: product.short_description_en || null,
          short_description_zh: product.short_description_zh || null,
          short_description_vi: product.short_description_vi || null,
          description: product.description_ru || null,
          description_en: product.description_en || null,
          description_zh: product.description_zh || null,
          description_vi: product.description_vi || null
        };
        
        if (isUpdate) {
          // Update existing product
          const { error: updateError } = await supabase
            .from('products')
            .update(dbProduct)
            .eq('id', product.id);
          
          if (updateError) {
            throw new Error(`Update failed: ${updateError.message}`);
          }
        } else {
          // Create new product
          const { error: insertError } = await supabase
            .from('products')
            .insert([dbProduct]);
          
          if (insertError) {
            throw new Error(`Insert failed: ${insertError.message}`);
          }
        }
        
        if (isUpdate) {
          updated++;
          console.log(`‚úÖ Updated: ${product.id}`);
        } else {
          created++;
          console.log(`‚úÖ Created new product`);
        }
      } catch (error) {
        const errorMsg = `Line ${i + 1}: ${String(error)}`;
        errors.push(errorMsg);
        console.error(`‚ùå ${errorMsg}`);
      }
    }
    
    console.log(`‚úÖ Import complete: ${updated} updated, ${created} created, ${errors.length} errors`);
    
    return c.json({
      success: true,
      updated,
      created,
      errors: errors.length > 0 ? errors : undefined
    });
  } catch (error) {
    console.error('‚ùå Error importing catalog:', error);
    return c.json({ error: 'Failed to import catalog', details: String(error) }, 500);
  }
});

Deno.serve(app.fetch);
